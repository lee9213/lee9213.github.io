<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="F9B7AE033F8B45BAE6C0FCF06DD118A5">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"disqusjs","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="读万卷书，更要行万里路！">
<meta property="og:type" content="blog">
<meta property="og:title" content="李波的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="李波的博客">
<meta property="og:description" content="读万卷书，更要行万里路！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李波">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>李波的博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?a306ba7f95495f3af39fa0d1cfcc50ed"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="李波的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">李波的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李波"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">李波</p>
  <div class="site-description" itemprop="description">读万卷书，更要行万里路！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlZTkyMTM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lee9213"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxlZTkyMTNAMTYzLmNvbQ==" title="E-Mail → mailto:lee9213@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9leGFtcGxlLmNvbQ==" title="https:&#x2F;&#x2F;example.com">mysql1</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9leGFtcGxlLmNvbQ==" title="https:&#x2F;&#x2F;example.com">mysql2</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9leGFtcGxlLmNvbQ==" title="https:&#x2F;&#x2F;example.com">mysql3</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9leGFtcGxlLmNvbQ==" title="https:&#x2F;&#x2F;example.com">mysql4</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/dubbo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/20/dubbo/" class="post-title-link" itemprop="url">Dubbo</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-20 23:25:52" itemprop="dateCreated datePublished" datetime="2018-08-20T23:25:52+08:00">2018-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 16:06:39" itemprop="dateModified" datetime="2024-07-31T16:06:39+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
    </span>

  
    <span id="/2018/08/20/dubbo/" class="post-meta-item leancloud_visitors" data-flag-title="Dubbo" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>高性能RPC框架，主要用于服务治理。包括功能：</p>
<ul>
<li>负载均衡（默认加权随机）</li>
<li>集群容错（默认failover）</li>
<li>服务降级</li>
<li>监控（Monitor）<ul>
<li>提供者和消费者定时每分钟发送一次统计数据到监控中心</li>
</ul>
</li>
<li>服务注册与发现<br>特点：连通性、健壮性、伸缩性
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/08/20/dubbo/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/26/classloader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/26/classloader/" class="post-title-link" itemprop="url">JVM之类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-26 12:05:40" itemprop="dateCreated datePublished" datetime="2018-07-26T12:05:40+08:00">2018-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span id="/2018/07/26/classloader/" class="post-meta-item leancloud_visitors" data-flag-title="JVM之类加载器" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java类加载器是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="BootStrap-ClassLoader（启动类加载器）"><a href="#BootStrap-ClassLoader（启动类加载器）" class="headerlink" title="BootStrap ClassLoader（启动类加载器）"></a>BootStrap ClassLoader（启动类加载器）</h2><ul>
<li>负责加载<JAVA_HOME>&#x2F;jre&#x2F;lib目录下的jar包和Class文件。可以通过System.getProperty(“sun.boot.class.path”)获取加载的路径。</li>
</ul>
<h2 id="Extension-ClassLoader（扩展类加载器）"><a href="#Extension-ClassLoader（扩展类加载器）" class="headerlink" title="Extension ClassLoader（扩展类加载器）"></a>Extension ClassLoader（扩展类加载器）</h2><ul>
<li>负责加载<JAVA_HOME>&#x2F;jre&#x2F;lib&#x2F;ext或java.ext.dirs指定目录下的jar包。</li>
</ul>
<h2 id="App-ClassLoader（系统类加载器或应用类加载器）"><a href="#App-ClassLoader（系统类加载器或应用类加载器）" class="headerlink" title="App ClassLoader（系统类加载器或应用类加载器）"></a>App ClassLoader（系统类加载器或应用类加载器）</h2><ul>
<li>负责加载ClassPath或java.class.path目录下的jar包和Class文件。可通过ClassLoader.getSystemClassLoader()来获取。</li>
<li>可以通过指定java.system.class.loader来自定义系统类加载器。</li>
</ul>
<h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><ul>
<li>继承自ClassLoader类，重写findClass()方法</li>
</ul>
<h2 id="类加载器关系"><a href="#类加载器关系" class="headerlink" title="类加载器关系"></a>类加载器关系</h2><ul>
<li>类加载器直接的关系并非继承关系，而是包含关系。</li>
<li>启动类加载器没有父类。</li>
<li>扩展类加载器的父类为null。</li>
<li>系统类加载器的父类为sun.misc.Launcher$ExtClassLoader</li>
<li>自定义类加载器的父类默认为sun.misc.Launcher$AppClassLoader</li>
</ul>
<hr>
<h1 id="类加载模式"><a href="#类加载模式" class="headerlink" title="类加载模式"></a>类加载模式</h1><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><ul>
<li>如果一个类加载器接收到类加载请求，首先把这个请求委派给父类加载器去完成，每一层类加载器都是如此；只有当父类加载器无法完成这个加载请求时，子加载器才会尝试自己去加载。</li>
</ul>
<h2 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h2><ul>
<li>可以确保Java核心库的类型安全。</li>
<li>可以确保Java核心库所提供的类不会被自定义的类所代替。</li>
<li>不同的类加载器可以为相同的名称的类创建额外的命名空间。</li>
</ul>
<h2 id="双亲委派模型的规则"><a href="#双亲委派模型的规则" class="headerlink" title="双亲委派模型的规则"></a>双亲委派模型的规则</h2><ul>
<li>父类加载器加载的类不能访问自类加载器加载的类。</li>
<li>子类加载器加载的类可以访问父类加载器加载的类</li>
</ul>
<h2 id="线程上下文类加载器（破坏了双亲委派模型）"><a href="#线程上下文类加载器（破坏了双亲委派模型）" class="headerlink" title="线程上下文类加载器（破坏了双亲委派模型）"></a>线程上下文类加载器（破坏了双亲委派模型）</h2><ul>
<li>在双亲委托模型下，类加载是由下向上的，即下层的类加载器委托上层进行加载。但是对于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VydmljZV9wcm92aWRlcl9pbnRlcmZhY2U=">SPI<i class="fa fa-external-link-alt"></i></span>来说，有些接口是JAVA核心库所提供的，而Java和核心库是由启动类加载器来加载的，而这些接口的实现却来自不同的jar包（厂商提供），Java的启动类是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VydmljZV9wcm92aWRlcl9pbnRlcmZhY2U=">SPI<i class="fa fa-external-link-alt"></i></span>的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">try&#123;</span><br><span class="line">	Thread.currentThread().setContextClassLoader(appClassLoader);</span><br><span class="line">	//具体业务逻辑实现</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="类加载器加载过程"><a href="#类加载器加载过程" class="headerlink" title="类加载器加载过程"></a>类加载器加载过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul>
<li>查找并加载类的二进制数据，并放入内存中。</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>验证：确保被加载的类的正确性。（类文件结构检查；语义检查；字节码检查；二进制兼容性的验证）</li>
<li>准备：为类的静态变量分配内存，并将初始化默认值。</li>
<li>解析：把类中的符号引用转化为直接引用。<ul>
<li>符号引用：在编译时，Java类并不知道所引用的类的实际地址，因此只能使用符号来代替。</li>
<li>直接引用：直接执向目标的指针。</li>
</ul>
</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li>为类的静态变量赋予正确的初始值。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul>
<li>JVM自带的类加载器加载的类，在JVM的生命周期中，始终不会被卸载。</li>
<li>用户自定义的类加载器所加载的类是可以被卸载的。</li>
</ul>
<hr>
<h1 id="类加载器时机"><a href="#类加载器时机" class="headerlink" title="类加载器时机"></a>类加载器时机</h1><ul>
<li>JVM虚拟机必须在每个类或接口被Java程序首次主动使用时才初始化。</li>
<li>主动使用<ul>
<li>通过new创建一个类的实例</li>
<li>反射Class.forName()</li>
<li>访问类的静态变量或静态方法</li>
<li>为一个类的静态变量赋值</li>
<li>初始化一个类时，父类未初始化时，先初始化父类</li>
<li>虚拟机启动时，定义了main方法的类</li>
</ul>
</li>
</ul>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/10/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">性能调优</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-10 21:07:37" itemprop="dateCreated datePublished" datetime="2018-09-10T21:07:37+08:00">2018-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span id="/2018/09/10/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" class="post-meta-item leancloud_visitors" data-flag-title="性能调优" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li><code>P</code> 按照CPU占用降序排序</li>
<li><code>M</code> 按照内存占用降序排序</li>
<li><code>T</code> 按照运行时间降序排序</li>
<li><code>N</code> 按照PID降序排序</li>
<li><code>H</code> 进程和线程之间切换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">列名    含义</span><br><span class="line">PID    进程id</span><br><span class="line">PPID    父进程id</span><br><span class="line">RUSER    Realusername</span><br><span class="line">UID    进程所有者的用户id</span><br><span class="line">USER    进程所有者的用户名</span><br><span class="line">GROUP    进程所有者的组名</span><br><span class="line">TTY    启动进程的终端名。不是从终端启动的进程则显示为?</span><br><span class="line">PR       优先级</span><br><span class="line">NInice     值。负值表示高优先级，正值表示低优先级</span><br><span class="line">P        最后使用的CPU，仅在多CPU环境下有意义</span><br><span class="line">%CPU    上次更新到现在的CPU时间占用百分比</span><br><span class="line">TIME    进程使用的CPU时间总计，单位秒</span><br><span class="line">TIME+    进程使用的CPU时间总计，单位1/100秒</span><br><span class="line">%MEM    进程使用的物理内存百分比</span><br><span class="line">VIRT    进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line">SWAP    进程使用的虚拟内存中，被换出的大小，单位kb。</span><br><span class="line">RES    进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class="line">CODE    可执行代码占用的物理内存大小，单位kb</span><br><span class="line">DATA    可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</span><br><span class="line">SHR    共享内存大小，单位kb</span><br><span class="line">nFLT    页面错误次数</span><br><span class="line">nDRT    最后一次写入到现在，被修改过的页面数。</span><br><span class="line">S    进程状态。</span><br><span class="line">D=    不可中断的睡眠状态</span><br><span class="line">R=    运行</span><br><span class="line">S=    睡眠</span><br><span class="line">T=    跟踪/停止</span><br><span class="line">Z=    僵尸进程</span><br><span class="line">COMMAND    命令名/命令行</span><br><span class="line">WCHAN    若该进程在睡眠，则显示睡眠中的系统函数名</span><br></pre></td></tr></table></figure>

<h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>查看io信息，对系统的磁盘操作活动进行监视，如<code>iostat -xd 1</code></p>
<h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-c 显示CPU使用情况</span><br><span class="line">-d 显示磁盘使用情况</span><br><span class="line">-k 以 KB 为单位显示</span><br><span class="line">-m 以 M 为单位显示</span><br><span class="line">-N 显示磁盘阵列(LVM) 信息</span><br><span class="line">-n 显示NFS 使用情况</span><br><span class="line">-p[磁盘] 显示磁盘和分区的情况</span><br><span class="line">-t 显示终端和CPU的信息</span><br><span class="line">-x 显示详细信息</span><br><span class="line">-V 显示版本信息</span><br></pre></td></tr></table></figure>

<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>可以显示当前系统未使用的和已使用的内存数目</p>
<h3 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li><code>-b</code>(Byte)、<code>-k</code>(KB)、<code>-m</code>(MB)、<code>-o</code>(不显示缓冲区调节列)、</li>
</ul>
<h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>显示虚拟内存状态（“Viryual Memor Statics”）</p>
<h3 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-a：显示活动内页；</span><br><span class="line">-f：显示启动后创建的进程总数；</span><br><span class="line">-m：显示slab信息；</span><br><span class="line">-n：头信息仅显示一次；</span><br><span class="line">-s：以表格方式显示事件计数器和内存状态；</span><br><span class="line">-d：报告磁盘状态；</span><br><span class="line">-p：显示指定的硬盘分区状态；</span><br><span class="line">-S：输出信息的单位</span><br></pre></td></tr></table></figure>

<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>jstat -gcutil [pid]</p>
<h2 id="nicstat"><a href="#nicstat" class="headerlink" title="nicstat"></a>nicstat</h2><h2 id="查看线程占用cpu"><a href="#查看线程占用cpu" class="headerlink" title="查看线程占用cpu"></a>查看线程占用cpu</h2><ul>
<li><code>top</code> 查看对应java程序的进程ID</li>
<li><code>jstack [pid] &gt; stack.txt</code> 使用jstack将堆栈导出</li>
<li><code>top -H</code> 查看对应java程序的线程ID</li>
<li><code>printf &quot;%x \n&quot; [线程ID] </code> 将10进制的线程ID转成16进制的线程ID</li>
<li>在之前导出的stack.txt文件中即可找到对应线程ID的线程</li>
</ul>
<h2 id="监控软件"><a href="#监控软件" class="headerlink" title="监控软件"></a>监控软件</h2><ul>
<li>zipkin</li>
<li>cat</li>
<li>zabbix nagios</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">微服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-05 21:06:40" itemprop="dateCreated datePublished" datetime="2018-09-05T21:06:40+08:00">2018-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span id="/2018/09/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-meta-item leancloud_visitors" data-flag-title="微服务" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="传统架构问题"><a href="#传统架构问题" class="headerlink" title="传统架构问题"></a>传统架构问题</h3><ul>
<li>系统资源浪费（水平扩展需要扩展整个应用，不能扩展单个模块）</li>
<li>部署效率低（修改了一行代码，需要部署整个应用）</li>
<li>技术选型单一</li>
</ul>
<h3 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h3><ul>
<li>微小度颗粒（细粒度）</li>
<li>服务单一简单（责任单一性），易于开发、理解和维护</li>
<li>运行隔离性，独立部署</li>
<li>管理自动化</li>
<li>扩展性高</li>
<li>服务内部高内聚、低耦合</li>
</ul>
<h3 id="微服务面临挑战"><a href="#微服务面临挑战" class="headerlink" title="微服务面临挑战"></a>微服务面临挑战</h3><ul>
<li>运维成本高</li>
<li>代码重复</li>
<li>分布式系统复杂性（网络延迟、系统容错、分布式事务）</li>
<li>部署依赖强（服务调用顺序）</li>
<li>通信成本高</li>
</ul>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>根据业务模块划分服务种类（垂直拆分）</li>
<li>每个服务可独立部署且相互隔离</li>
<li>通过轻量级API调用服务（Http或RMI）</li>
<li>服务需要保证良好的高可用性</li>
</ul>
<h4 id="交付流程"><a href="#交付流程" class="headerlink" title="交付流程"></a>交付流程</h4><ul>
<li>Design<ul>
<li>功能拆分，设计API接口，给出API文档</li>
</ul>
</li>
<li>Develop<ul>
<li>实现API接口，API单元测试</li>
</ul>
</li>
<li>Test<ul>
<li>测试环境，针对测试用例进行手工或自动化测试</li>
<li>预上线环境，冒烟测试</li>
<li>生产环境</li>
</ul>
</li>
<li>Deploy</li>
</ul>
<h4 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h4><h5 id="分支要求"><a href="#分支要求" class="headerlink" title="分支要求"></a>分支要求</h5><ul>
<li>master分支拉一个develop分支</li>
<li>开发功能时，从develop分支拉一个feature分支，如果多个功能就拉多个分支</li>
<li>当feature开发完成后，从develop分支上拉一个release分支</li>
<li>将所有feature分支合并到release分支上，对release分支部署测试环境，进行功能测试</li>
<li>如果有bug则在release分支上修改，等到无bug时，将release分支部署到预上线环境，再次验证</li>
<li>如果无bug则将release分支部署到生产环境中，待上线完成后，将release分支合并到develop分支和master分支</li>
<li>并且在master分支上打一个tag</li>
<li>如果生产环境有bug，则从对应的tag上拉一个hotfix分支，并在该分支上进行bug修复</li>
<li>待bug修复完成之后，将hotfix分支上的代码合并到develop分支和master分支</li>
</ul>
<h5 id="版本号的要求"><a href="#版本号的要求" class="headerlink" title="版本号的要求"></a>版本号的要求</h5><ul>
<li>格式为x.y.z<ul>
<li>x用于有重大重构时升级</li>
<li>y用于有新特性发布时才会升级</li>
<li>z用于修改了某个bug后才会升级</li>
</ul>
</li>
</ul>
<h4 id="微服务架构模式"><a href="#微服务架构模式" class="headerlink" title="微服务架构模式"></a>微服务架构模式</h4><ul>
<li>核心模式</li>
<li>部署模式</li>
<li>通信模式</li>
<li>服务发现模式</li>
<li>数据管理模式</li>
</ul>
<h3 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h3><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>Json Web Tokens，一种易于使用、无状态的鉴权方式</p>
<h3 id="RESTFul-API"><a href="#RESTFul-API" class="headerlink" title="RESTFul API"></a>RESTFul API</h3><ul>
<li>幂等<ul>
<li>GET</li>
<li>PUT</li>
<li>DELETE</li>
</ul>
</li>
<li>非幂等<ul>
<li>POST</li>
<li>PATCH</li>
</ul>
</li>
</ul>
<h3 id="如何保证接口的幂等性"><a href="#如何保证接口的幂等性" class="headerlink" title="如何保证接口的幂等性"></a>如何保证接口的幂等性</h3><ul>
<li>全局ID</li>
<li>版本号控制</li>
<li>状态机控制</li>
</ul>
<h3 id="最终一致性的实现方案"><a href="#最终一致性的实现方案" class="headerlink" title="最终一致性的实现方案"></a>最终一致性的实现方案</h3><ul>
<li>同步写</li>
<li>异步MQ同步</li>
<li>日志同步</li>
</ul>
<h3 id="如何应对微服务的链式调用异常"><a href="#如何应对微服务的链式调用异常" class="headerlink" title="如何应对微服务的链式调用异常"></a>如何应对微服务的链式调用异常</h3><ul>
<li>MQ解耦</li>
<li>Hystrix熔断</li>
<li>Sleuth+Zipkin链路追踪</li>
</ul>
<h3 id="如何保证微服务的安全-认证"><a href="#如何保证微服务的安全-认证" class="headerlink" title="如何保证微服务的安全&#x2F;认证"></a>如何保证微服务的安全&#x2F;认证</h3><ul>
<li>单点登陆</li>
<li>分布式session</li>
<li>客户端token（JWT、OAuth2.0）</li>
<li>客户端token和API网关结合</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/01/thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/01/thread/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-01 21:04:48" itemprop="dateCreated datePublished" datetime="2018-09-01T21:04:48+08:00">2018-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span id="/2018/09/01/thread/" class="post-meta-item leancloud_visitors" data-flag-title="多线程" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="多线程使用场景"><a href="#多线程使用场景" class="headerlink" title="多线程使用场景"></a>多线程使用场景</h3><ul>
<li>通过并行计算提高程序执行性能</li>
<li>需要等待网络、I&#x2F;O响应导致耗费大量的执行时间，可以采用异步线程的方式来减少阻塞</li>
</ul>
<h3 id="如何应用多线程"><a href="#如何应用多线程" class="headerlink" title="如何应用多线程"></a>如何应用多线程</h3><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>使用ExecutorService、Callable、Future实现带返回结果的多线程</li>
</ul>
<h3 id="线程的状态（6种）"><a href="#线程的状态（6种）" class="headerlink" title="线程的状态（6种）"></a>线程的状态（6种）</h3><ul>
<li><p>NEW：初始状态，线程被构建，还没有调用start方法。</p>
</li>
<li><p>RUNNABLED：运行状态，Java线程把操作系统中的就绪和运行两种状态同一为“运行中”。</p>
</li>
<li><p>BLOCKED：阻塞状态，表示线程进入等待状态，也就是线程因为某种原因放弃了CPU使用权。</p>
<ul>
<li>等待阻塞：运行的线程执行wait方法，JVM会把当前线程放入等待队列</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程占用，那JVM会把当前的线程放入到锁池中</li>
<li>其他阻塞：运行的线程执行<code>Thread.sleep</code>或者<code>t.join</code>方法，或者发出了I&#x2F;O请求时，JVM会把当前线程设置为阻塞状态，当sleep结束、join线程终止、I&#x2F;O处理完毕则线程恢复</li>
</ul>
</li>
<li><p>WAITING：等待状态，运行的线程执行以下方法，当前线程会进入等待状态</p>
<ul>
<li><code>Object.wait</code></li>
<li><code>Object.join</code></li>
<li><code>LockSupport.park</code></li>
</ul>
</li>
<li><p>TIME_WAITING：超时等待状态，运行的线程执行以下方法，当前线程会进入超时等待状态</p>
<ul>
<li><code>Thread.sleep</code></li>
<li><code>Object.wait with timeout</code></li>
<li><code>Thread.join with timeout</code></li>
<li><code>LockSupport.parkNanos</code></li>
<li><code>LockSupport.parkUntil</code></li>
</ul>
</li>
</ul>
<p>TER</p>
<ul>
<li>TERMINATED：终止状态，表示当前线程执行完毕</li>
</ul>
<h3 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h3><ul>
<li>isInterrupted：默认情况下，在通过调用线程对象的isInterrupted方法返回false</li>
<li>interrupt：线程中断，调用线程对象的interrupt方法之后，再通过调用线程对象的isInterrupted方法返回true</li>
<li>interrupted ：线程复位，调用Thread.interrupted 方法之后，再通过调用线程对象的isInterrupted方法返回false</li>
</ul>
<h3 id="线程的停止"><a href="#线程的停止" class="headerlink" title="线程的停止"></a>线程的停止</h3><ul>
<li>通过interrupt方法实现中断线程</li>
<li>通过volatile共享变量实现中断线程</li>
</ul>
<h3 id="线程复位"><a href="#线程复位" class="headerlink" title="线程复位"></a>线程复位</h3><p>线程复位就是将调用线程的isInterrupted方法返回设置为false</p>
<ul>
<li>调用Thread.interrupted</li>
<li>抛出InterruptedException异常，JVM会把线程的中断标识位清除</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>可重入锁（递归锁，当一个线程获得了当前实例的锁，并进入方法A，这个线程在没有释放这把锁的情况下，可以再次进入方法A（递归））<ul>
<li>ReentrantLock<ul>
<li>乐观锁</li>
<li>可中断</li>
<li>公平锁和非公平锁</li>
<li>可以判断锁状态</li>
</ul>
</li>
<li>synchronized<ul>
<li>重量级锁&#x2F;监视器锁</li>
<li>CPU悲观锁机制</li>
<li>不可中断</li>
<li>非公平</li>
<li>不能判断锁状态</li>
</ul>
</li>
</ul>
</li>
<li>wait&#x2F;nofity&#x2F;notifyAll</li>
</ul>
<h3 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h3><ul>
<li><p>程序顺序规则</p>
<p>一个线程中的每个操作，happens-before于随后该线程中的任意后续操作</p>
</li>
<li><p>监视器锁规则</p>
<p>对一个锁的解锁，happens-before于随后对这个锁的获取</p>
</li>
<li><p>volatile变量规则</p>
<p>对一个volatile域的写，happens-bofore于对这个变量的读</p>
</li>
<li><p>传递性</p>
<p>如果A happens-bofore B，B happens-bofore C，那么A happens-bofore C</p>
</li>
<li><p>start规则</p>
<p>如果线程A执行线程B的start方法，那么线程A的ThreadB.start happens-bofore于线程B的任意操作</p>
</li>
<li><p>join规则</p>
<p>如果线程A执行线程B的join方法，那么线程B的任意操作happens-bofore于线程A从ThreadB.join方法成功返回</p>
</li>
</ul>
<h3 id="线程安全性问题"><a href="#线程安全性问题" class="headerlink" title="线程安全性问题"></a>线程安全性问题</h3><h4 id="CPU高速缓存"><a href="#CPU高速缓存" class="headerlink" title="CPU高速缓存"></a>CPU高速缓存</h4><p>高速缓存从下到上越接近 CPU 速度越快，同时容量也越小。缓存又可以分为指令缓存和数据缓存，指令缓存用来缓存程序的代码，数据缓存用来缓存程序的数据。高速缓存分为：</p>
<ul>
<li>L1 Cache，一级缓存，本地 core 的缓存，分成 32K 的数据缓存 L1d 和 32k 指令缓存 L1i，访问 L1 需要 3cycles，耗时大约 1ns； </li>
<li>L2 Cache，二级缓存，本地 core 的缓存，被设计为 L1 缓存与共享的 L3 缓存之间的缓冲，大小为 256K，访问 L2 需要 12cycles，耗时大约 3ns； </li>
<li>L3 Cache，三级缓存，在同插槽的所有 core 共享 L3 缓存，分为多个 2M 的段，访问 L3 需要 38cycles，耗时大约 12ns；</li>
</ul>
<h4 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h4><h5 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h5><p>当一个 CPU 对其缓存中的数据进行操作的时候，往总线中发送一个 Lock 信号。其他处理器的请求将会被阻塞，那么该处理器可以独占共享内存。总线锁相当于把 CPU 和内存之间的通信锁住了，所以这种方式会导致 CPU 的性能下降，所以 P6 系列以后的处理器，出现了另外一种方式，就是缓存锁。 </p>
<h5 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h5><p>如果缓存在处理器缓存行中的内存区域在 LOCK 操作期间被锁定，当它执行锁操作回写内存时，处理不在总线上声明 LOCK 信号，而是修改内部的缓存地址，然后通过缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻 止同时修改被两个以上处理器缓存的内存区域的数据，当其他处理器回写已经被锁定的缓存行的数据时会导致该缓存行无效。 所以如果声明了 CPU 的锁机制，会生成一个 LOCK 指令，会产生两个作用 </p>
<ol>
<li>Lock 前缀指令会引起处理器缓存回写到内存，在 P6 以后的处理器中，LOCK 信号一般不锁总线，而是锁缓存 </li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</li>
</ol>
<h5 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h5><p>MESI 协议，在 CPU 缓存中保存一个标记位，这个标记为有四种状态</p>
<ul>
<li>M(Modified) 修改缓存，当前 CPU 缓存已经被修改，表示已经和内存中的数据不一致了 </li>
<li>I(Invalid) 失效缓存，说明 CPU 的缓存已经不能使用了 </li>
<li>E(Exclusive)  独占缓存，当前 cpu 的缓存和内存中数据保持一直，而且其他处理器没有缓存该数据 </li>
<li>S(Shared)   共享缓存，数据和内存中数据一致，并且该数据存在多个 cpu 缓存中</li>
</ul>
<p>每个 Core 的 Cache 控制器不仅知道自己的读写操作，也监听其它 Cache 的读写操作，嗅探（snooping）协议 ，CPU 的读取会遵循几个原则：</p>
<ol>
<li>如果缓存的状态是 I，那么就从内存中读取，否则直接从缓存读取 </li>
<li>如果缓存处于 M 或者 E 的 CPU 嗅探到其他 CPU 有读的操作，就把自己的缓存写入到内存，并把自己的状态设置为 S </li>
<li>只有缓存状态是 M 或 E 的时候，CPU 才可以修改缓存中的数据，修改后，缓存状态变为 MC</li>
</ol>
<h5 id="执行优化"><a href="#执行优化" class="headerlink" title="执行优化"></a>执行优化</h5><ul>
<li><p>CPU：为了更充分利用处理器内内部的运算单元，处理器可能会对输入的代码进行的<strong>乱序执行优化</strong></p>
</li>
<li><p>编译器：<strong>指令重排来提升性能</strong></p>
</li>
</ul>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><h5 id="x86的cpu的内存屏障"><a href="#x86的cpu的内存屏障" class="headerlink" title="x86的cpu的内存屏障"></a>x86的cpu的内存屏障</h5><ul>
<li>写屏障（store barrier），相当于storestore barrier，强制所有在storestore内存屏障之前的所有执行，都要在该内存屏障之前执行，并发送缓存失效的信号。所有在storestore barrier指令之后的store指令，都必须在 storestore barrier屏障之前的指令执行完后再被执行。<strong>禁止了写屏障前后的指令进行重排序</strong>。</li>
<li>读屏障（load barrier），相当于loadload barrier，强制所有在load barrier读屏障之后的load指令，都在load barrier屏障之后执行。<strong>禁止对load barrier读屏障前后的load指令进行重排序</strong>，配合store barrier，使得所有store barrier之前发生的内存更新，对load barrier之后的load操作是可见的。</li>
<li>全屏障（Full Barrier），相当于storeload，是一个全能型的屏障。它同时具备前面两种屏障的效果。。强制了 所有在storeload barrier之前的store&#x2F;load指令，都在该屏障之前被执行，所有在该屏障之后的的store&#x2F;load指 令，都在该屏障之后被执行。<strong>禁止对storeload屏障前后的指令进行重排序。</strong></li>
</ul>
<h5 id="Java编译层面的内存屏障"><a href="#Java编译层面的内存屏障" class="headerlink" title="Java编译层面的内存屏障"></a>Java编译层面的内存屏障</h5><ul>
<li>LoadLoad Barriers：load1 ; LoadLoad; load2 , 确保load1数据的装载优先于load2及所有后续装载指令的装载。</li>
<li>StoreStore Barriers：store1; storestore;store2 , 确保store1数据对其他处理器可见优先于store2及所有后续存储指令的存储</li>
<li>LoadStore Barries：load1;loadstore;store2, 确保load1数据装载优先于store2以及后续的存储指令刷新到内存 </li>
<li>StoreLoad Barries：store1; storeload;load2, 确保store1数据对其他处理器变得可见， 优先于load2及所有后续装载指令的装载；这条内存屏障指令是一个全能型的屏障。</li>
</ul>
<h4 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h4><p>原子性、可见性、有序性</p>
<ul>
<li><p>缓存一致性就导致可见性问题</p>
</li>
<li><p>处理器的乱序执行会导致原子性问题、</p>
</li>
<li><p>指令重排会导致有序性问题</p>
</li>
</ul>
<h5 id="synchronized（原子性、可见性、有序性）"><a href="#synchronized（原子性、可见性、有序性）" class="headerlink" title="synchronized（原子性、可见性、有序性）"></a>synchronized（原子性、可见性、有序性）</h5><p>通过monitorenter和monitorexit保证原子性、可见性、有序性</p>
<h5 id="volatile（可见性、有序性）"><a href="#volatile（可见性、有序性）" class="headerlink" title="volatile（可见性、有序性）"></a>volatile（可见性、有序性）</h5><ul>
<li>防止指令重排序<ul>
<li>内存屏障<ul>
<li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</li>
<li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</li>
</ul>
</li>
</ul>
</li>
<li>保证多线程操作时变量的可见性<ul>
<li>volatile变量修饰的共享变量，在进行写操作的时候会多处一个lock前缀的汇编指令，会触发总线锁或者缓存锁，通过缓存一致性协议来解决可见性问题</li>
</ul>
</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h5><ul>
<li>互斥</li>
<li>请求与保持</li>
<li>不剥夺</li>
<li>循环等待</li>
</ul>
<h5 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h5><ul>
<li>有序资源分配法</li>
<li>银行家算法</li>
</ul>
<h3 id="ThreadLocal为什么出现OOM？"><a href="#ThreadLocal为什么出现OOM？" class="headerlink" title="ThreadLocal为什么出现OOM？"></a>ThreadLocal为什么出现OOM？</h3><ul>
<li><p>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致内存泄漏</p>
</li>
<li><p>分配使用了ThreadLocal又不再调用get&#x2F;set&#x2F;remove方法，那么就会导致内存泄漏，因为这块内存一直存在</p>
</li>
</ul>
<p>当一个线程调用ThreadLocal的set方法设置变量时候，key为ThreadLocal的引用，value则为设置的值。如果当前线程一直存在而没有调用ThreadLocal的remove方法，由于线程的ThreadLocalMap里面的key是弱引用，则会在gc的时候被回收，但是对应的value是强引用，这时候ThreadLocalMap里面就会存在key为null但是value不为null的entry项，这样就会造成内存泄露。 ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p>
<h3 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h3><p>use		load	read	lock</p>
<p>assign	store	write	unlock</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/28/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/28/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">分布式架构设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-28 21:04:00" itemprop="dateCreated datePublished" datetime="2018-08-28T21:04:00+08:00">2018-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
    </span>

  
    <span id="/2018/08/28/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-meta-item leancloud_visitors" data-flag-title="分布式架构设计" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="分布式系统的意义"><a href="#分布式系统的意义" class="headerlink" title="分布式系统的意义"></a>分布式系统的意义</h3><ul>
<li>升级单机处理能力的性价比越来越低</li>
<li>单机处理能力存在瓶颈</li>
<li>单机系统稳定性和可靠性很难达到</li>
</ul>
<h3 id="分布式常见概念"><a href="#分布式常见概念" class="headerlink" title="分布式常见概念"></a>分布式常见概念</h3><ul>
<li>集群</li>
<li>节点<ul>
<li>节点是指一个可以独立按照分布式协议完成一组逻辑的程序个体</li>
</ul>
</li>
<li>副本机制<ul>
<li>副本是指在分布式系统中为数据或服务提供的冗余</li>
</ul>
</li>
<li>中间件</li>
</ul>
<h3 id="架构的发展过程"><a href="#架构的发展过程" class="headerlink" title="架构的发展过程"></a>架构的发展过程</h3><ul>
<li>单应用架构</li>
<li>应用服务器和数据库服务器分离</li>
<li>应用服务器集群-应用服务器负载告警</li>
<li>数据库读写分离</li>
<li>引入缓存机制缓解数据库的压力</li>
<li>数据库的水平&#x2F;垂直拆分</li>
</ul>
<h3 id="分布式系统的难点"><a href="#分布式系统的难点" class="headerlink" title="分布式系统的难点"></a>分布式系统的难点</h3><ul>
<li>三态</li>
<li>分布式事务</li>
<li>负载均衡</li>
<li>一致性</li>
<li>故障的独立性</li>
</ul>
<h3 id="微服务的特征"><a href="#微服务的特征" class="headerlink" title="微服务的特征"></a>微服务的特征</h3><ol>
<li>通过服务实现组件化</li>
<li>按业务能力来划分服务和开发团队</li>
<li>去中心化</li>
<li>基础设施自动化（devops、自动化部署）</li>
</ol>
<h3 id="SOA和微服务的差别"><a href="#SOA和微服务的差别" class="headerlink" title="SOA和微服务的差别"></a>SOA和微服务的差别</h3><ol>
<li>微服务不再强调传统SOA里面比较重的ESB企业总线服务，同时SOA的思想进入到单个业务系统内部实现真正的组件化</li>
<li>SOA注重的是系统集成方面，微服务关注的是完全分离</li>
</ol>
<h3 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h3><ul>
<li>界限上下文（包名）</li>
<li>实体（entity）</li>
<li>值对象（valobj）</li>
<li>聚合根（aggregate）</li>
<li>领域服务（service）</li>
<li>资源库（repo）</li>
</ul>
<h3 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h3><ul>
<li>一致性问题<ul>
<li>强一致性</li>
<li>弱一致性</li>
<li>最终一致性</li>
</ul>
</li>
<li>CAP理论<ul>
<li>Consistency：一致性</li>
<li>Availability：可用性</li>
<li>Partition tolerance：分区容错性</li>
</ul>
</li>
<li>BASE理论<ul>
<li>Basically available：基本可用</li>
<li>Soft State：软状态</li>
<li>Eventually Consistent：数据最终一致性</li>
</ul>
</li>
</ul>
<h3 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h3><ol>
<li>避免单点故障<ol>
<li>负载均衡技术（failover&#x2F;选址&#x2F;硬件负载&#x2F;软件负载&#x2F;去中心化的软件负载（gossip（redis-cluster）））</li>
<li>热备（Linux HA）</li>
<li>多机房（同城灾备、异地灾备）</li>
</ol>
</li>
<li>应用的高可用性<ol>
<li>故障监控（系统监控（cpu、内存）&#x2F;链路监控&#x2F;日志监控）自动预警</li>
<li>应用的容错设计（服务降级、限流）、自我保护能力</li>
<li>数据量（数据分片、读写分离）</li>
</ol>
</li>
</ol>
<h3 id="分布式架构的可伸缩设计"><a href="#分布式架构的可伸缩设计" class="headerlink" title="分布式架构的可伸缩设计"></a>分布式架构的可伸缩设计</h3><ul>
<li>垂直伸缩（提升硬件能力）</li>
<li>水平伸缩（增加服务器）</li>
<li>加速静态内容访问速度的CDN</li>
</ul>
<h3 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h3><ul>
<li>百度 -&gt; DisConf</li>
<li>携程 -&gt; Appllo</li>
<li>阿里 -&gt; Nacos</li>
<li>Spring Cloud Config</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/%E5%88%86%E5%B8%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/26/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-title-link" itemprop="url">分布式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-26 21:01:56" itemprop="dateCreated datePublished" datetime="2018-08-26T21:01:56+08:00">2018-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
    </span>

  
    <span id="/2018/08/26/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-meta-item leancloud_visitors" data-flag-title="分布式" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul>
<li><p>Consistency（一致性）</p>
<p>所有节点同一时间的数据完全一致</p>
</li>
<li><p>Availability（可用性）</p>
<p>每次请求都能获取到非错的响应</p>
</li>
<li><p>Partition Tolerance（分区容错）</p>
<p>当某节点或网络分区故障的时候，系统仍能够对外提供满足一致性和可用性的服务</p>
</li>
</ul>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><ul>
<li><p>Basically Consistency（基本可用）</p>
<p>系统发生不可预知的故障，运行损失部分可用性</p>
<ul>
<li>响应时间损失，延长响应时间</li>
<li>功能损失，降级页面</li>
</ul>
</li>
<li><p>Soft State（软状态）</p>
<p>数据副本在整个运行期间，允许某一时刻存在中间状态，但是最终数据的状态保持一致</p>
</li>
<li><p>Eventually Consistent（最终一致性）</p>
<p>在经过一定时间后，所有数据副本的状态都已经保持一致</p>
</li>
</ul>
<h3 id="一致性算法"><a href="#一致性算法" class="headerlink" title="一致性算法"></a>一致性算法</h3><ul>
<li>paxos<ul>
<li>基于消息传递且具有高度容错性的一致性算法</li>
</ul>
</li>
<li>raft</li>
</ul>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul>
<li>算法<ul>
<li>令牌桶<ul>
<li>按照固定的速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为0时则拒绝新的请求</li>
<li>限制的是平均流入速率，并允许一定程度突发流量</li>
</ul>
</li>
<li>漏桶<ul>
<li>按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新入的请求被拒绝</li>
<li>限制的是常量流出速率，从而平滑突发流入速率</li>
</ul>
</li>
<li>计数器<ul>
<li>滑动窗口算法</li>
</ul>
</li>
</ul>
</li>
<li>实现方案<ul>
<li>Nginx<ul>
<li><code>ngx_http_limit_conn_module</code>连接数限流模块</li>
<li><code>ngx_http_limit_req_module</code>请求限流模块（漏桶算法）</li>
</ul>
</li>
<li>Guava<ul>
<li><code>RateLimiter</code>令牌桶算法<ul>
<li><code>SmoothBursty</code>平滑突发限流</li>
<li><code>SmoothWarmingUp</code>平滑预热限流</li>
</ul>
</li>
</ul>
</li>
<li>Tomcat<ul>
<li><code>maxConnections</code>最大连接数</li>
<li><code>maxThreads</code>最大线程数</li>
<li><code>acceptCount</code>当tomgcat线程数达到最大时，接受排队的请求个数</li>
</ul>
</li>
<li>redis+lua</li>
<li>nginx+lua</li>
</ul>
</li>
</ul>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><ul>
<li><p>缓存</p>
</li>
<li><p>消息队列，推模式改成拉模式</p>
</li>
</ul>
<h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><ul>
<li>当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时</li>
<li>HyStrix</li>
</ul>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><ul>
<li>当某个服务熔断之后，服务器将不再被调用，此时客户端返回一个缺省值</li>
</ul>
<h2 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h2><ul>
<li><p>session replication（session复制）</p>
</li>
<li><p>session sticky（固定同一台请求）</p>
</li>
<li><p>缓存集中式（Redis存session）</p>
</li>
</ul>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="数据结构类型"><a href="#数据结构类型" class="headerlink" title="数据结构类型"></a>数据结构类型</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul>
<li>sds（simple dynamic string）简单动态字符串</li>
<li>dict 维护key-value映射关系</li>
<li>quicklist</li>
<li>ziplist</li>
<li>skiplist</li>
<li>robj</li>
<li>intset</li>
</ul>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul>
<li>String<ul>
<li>set&#x2F;get&#x2F;decr&#x2F;incr</li>
</ul>
</li>
<li>Hash<ul>
<li>hset&#x2F;hget&#x2F;hexists</li>
</ul>
</li>
<li>List<ul>
<li>lpush&#x2F;rpush&#x2F;lpop&#x2F;rpop&#x2F;llen</li>
</ul>
</li>
<li>Set<ul>
<li>sadd&#x2F;srem&#x2F;scard&#x2F;sismember</li>
</ul>
</li>
<li>Sort Set<ul>
<li>zadd&#x2F;zcard&#x2F;zcount&#x2F;zrange&#x2F;zrem&#x2F;zscore</li>
</ul>
</li>
<li>transaction<ul>
<li>multi&#x2F;exec&#x2F;discard&#x2F;watch</li>
<li>Redis Cluster不支持</li>
</ul>
</li>
<li>pipeline<ul>
<li>JedisClusterConnection不支持</li>
<li>LettuceClusterConnection支持</li>
<li>openPipeline&#x2F;closePipeline</li>
<li>需注意批量命令大小，防止返回值超出内存</li>
<li>节省网络延迟的时间，非线程安全</li>
</ul>
</li>
</ul>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><ul>
<li>RDB<ul>
<li>快照，Redis支持将当前数据的快照存成一个数据文件的持久化机制</li>
</ul>
</li>
<li>AOF<ul>
<li>日志，append only file，追加写入的日志文件，可识别的纯文本，它的内容就是一个redis标准命令</li>
</ul>
</li>
</ul>
<h4 id="过期回收策略"><a href="#过期回收策略" class="headerlink" title="过期回收策略"></a>过期回收策略</h4><ul>
<li><code>noeviction</code>不回收</li>
<li><code>allkeys-lru</code>从所有键中删除最近最少使用的键</li>
<li><code>allkeys-random</code>从所有键中随机删除</li>
<li><code>volatile-lru</code>从设置了过期时间的键中删除最近最少使用的键</li>
<li><code>volatile-random</code>从设置了过期时间的键中随机删除</li>
<li><code>volatile-ttl</code>从设置了过期时间的键中选中存活时间最短的键删除</li>
</ul>
<h4 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h4><ul>
<li>Redis Cluster（官方）<ul>
<li>客户端直连Redis，免去了proxy代理的损耗</li>
<li>去中心化，最大可增加1000个节点，性能随节点增加而线性扩展</li>
<li>使用hash slot方式 将16384个hash slot 覆盖到所有节点上</li>
<li>简单易上手，管理方便，可自行增加或摘除节点，移动分槽等</li>
<li>一致性hash思想</li>
<li>不支持事务，不支持数据库切换，不支持mget，单个数据库</li>
</ul>
</li>
<li>codis（豌豆荚）<ul>
<li>多了一层代理</li>
<li>支持透明的扩&#x2F;缩容</li>
<li>具有图形化管理和监控工具，运维方便</li>
<li>数据根据key分布到1024个slot内</li>
</ul>
</li>
</ul>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li>缓存雪崩<ul>
<li>数据未加载到缓存中，同一时间缓存全部失效，导致所有请求到查数据库</li>
<li>解决方法<ul>
<li>通过加锁控制缓存失效对数据库造成的压力</li>
<li>尽量让失效时间点均匀分布</li>
<li>二级缓存</li>
</ul>
</li>
</ul>
</li>
<li>缓存击穿<ul>
<li>类似缓存雪崩，缓存雪崩针对多个key，缓存击穿针对单个key过期，恰好在这个点有大并发的请求过滤，导致所有请求都到数据库</li>
<li>解决方法<ul>
<li>分布式锁</li>
</ul>
</li>
</ul>
</li>
<li>缓存穿透<ul>
<li>查询一个一定不存在的数据，导致每次都需要从数据库区查</li>
<li>解决方法<ul>
<li>对查询结果为空的情况也进行缓存，过期时间设置短一点</li>
<li>对一定不存在的key进行过滤</li>
</ul>
</li>
</ul>
</li>
<li>缓存预热<ul>
<li>系统上线前，将数据加载到缓存中</li>
<li>解决方法<ul>
<li>定时刷新缓存</li>
<li>单个缓存预热框架</li>
</ul>
</li>
</ul>
</li>
<li>缓存更新<ul>
<li>定时清理过期缓存，先判断缓存是否过期，过期再冲数据库查</li>
</ul>
</li>
<li>缓存降级<ul>
<li>对于不重要的数据，Redis故障，不查数据库，直接返回默认值</li>
</ul>
</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li>实现方案<ul>
<li>框架：redisson（内部lua脚本）</li>
<li>redlock算法<ul>
<li>尝试从N个相互独立的Redis实例获取锁，如果一个实例不可用，应该尽快尝试下一个</li>
<li>计算获取锁消耗时间，只有当这个时间小于锁的过期时间，并且从大多数（N&#x2F;2+1）实例上获取了锁，那么就认为锁获取成功了</li>
<li>如果获锁获取失败，会到每个实例上释放锁</li>
</ul>
</li>
<li>lua脚本实现</li>
</ul>
</li>
<li>优缺点<ul>
<li>性能高，可靠性没有zookeeper的高</li>
</ul>
</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li>实现方案<ul>
<li>Curator</li>
</ul>
</li>
<li>优缺点<ul>
<li>性能没有Redis高，可靠性高</li>
</ul>
</li>
</ul>
<h2 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h2><h3 id="Redis-2"><a href="#Redis-2" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li>轻量级，用于实时性较高的消息推送，不保证可靠性</li>
<li>没有相应的机制保证消息的消费，消费者消费失败，消息丢失</li>
<li>可靠发布&#x2F;队列监控&#x2F;流量控制都需要自行实现</li>
</ul>
<h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><ul>
<li>支持持久化（内存&#x2F;文件&#x2F;数据库）</li>
<li>支持事务</li>
<li>支持协议（OpenWire&#x2F;STOMP&#x2F;REST&#x2F;XMPP&#x2F;AMQP）</li>
<li>可能出现消息丢失，不适合上千个队列的应用场景</li>
<li>社区不够活跃，5.x维护较少</li>
</ul>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul>
<li>性能好，具有持久化（内存&#x2F;文件）和消息确认机制，可靠性高</li>
<li>支持事务</li>
<li>支持协议（STOMP&#x2F;SMPP&#x2F;XMPP&#x2F;AMQP）</li>
<li>集群不支持动态扩展</li>
</ul>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul>
<li>高吞吐量，高可用性，严格保证消息顺序</li>
<li>支持持久化（磁盘文件）</li>
<li>支持事务</li>
<li>自已定义的一套协议</li>
<li>支持单机1万以上的持久化队列</li>
</ul>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul>
<li>吞吐量高</li>
<li>基于pull模式来处理消息消费，主要用于日志收集和传输</li>
<li>不支持事务</li>
</ul>
<h3 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h3><ul>
<li>扩展性号，开发必须灵活，socket库的重新封装</li>
<li>不能持久化</li>
<li>不支持事务</li>
<li>不支持负载均衡</li>
</ul>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>消息队列使用场景<ul>
<li>异步处理，比如注册发送短信或邮件</li>
<li>应用解耦，比如用户下单，订单系统通知库存系统</li>
<li>流量削峰，比如控制流量暴增</li>
<li>消息通讯，比如点对点消息队列&#x2F;聊天室</li>
</ul>
</li>
<li>消息幂等<ul>
<li>全局ID，业务ID</li>
</ul>
</li>
<li>消息重发补偿<ul>
<li>指数退避策略，先隔x秒重发，2x秒重发，4x秒重发，以此类推</li>
</ul>
</li>
<li>消息堆积<ul>
<li>增加消费者的处理能力或减少发布频率；给消息设置年龄，超时就丢弃</li>
</ul>
</li>
<li>消息有序<ul>
<li>通过hash分配到一个队列里，每个队列只有一个消费者</li>
</ul>
</li>
</ul>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h3><ul>
<li>步骤<ul>
<li>准备阶段<ul>
<li>协调者询问所有的参与者是否可以提交事务</li>
<li>参与者执行询问发起为止的所有事务操作，并将Undo和Redo信息记录到事务日志中</li>
<li>各参与者响应协调者发起的询问，如果参与者阶段事务执行成功，返回同意，否则返回中止</li>
</ul>
</li>
<li>提交阶段<ul>
<li>协调者收到同意，则向参与者发起正式提交事务的请求，否则向参与者发起回滚事务的请求</li>
</ul>
</li>
</ul>
</li>
<li>实现案例<ul>
<li>TCC补偿模式<ul>
<li>Try 预留业务资源</li>
<li>Confirm 确认执行业务操作</li>
<li>Cancel 取消执行业务操作</li>
</ul>
</li>
<li>DTS</li>
<li>JTA</li>
</ul>
</li>
<li>缺点<ul>
<li>同步阻塞</li>
<li>数据不一致<ul>
<li>在阶段二中，如果协调者发送commit之后，网络故障，导致部分参与者收到了commit请求，这时收到了commit请求的参与者执行了事务提交，其他参与者无法进行提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h3><ul>
<li>步骤<ul>
<li>CanCommit<ul>
<li>协调者询问所有参与者是否可以执行事务</li>
</ul>
</li>
<li>PreCommit<ul>
<li>协调者向所有参与者发送preCommit请求，并进入Prepared阶段</li>
<li>参与者收到preCommit请求后，会执行事务，并将Undo和Redo信息记录到事务日志中</li>
<li>参与者反馈给协调者</li>
</ul>
</li>
<li>doCommit<ul>
<li>向所有参与者发送commit请求</li>
<li>参与者收到doCommit请求后，执行事务提交操作</li>
</ul>
</li>
</ul>
</li>
<li>缺点<ul>
<li>数据不一致<ul>
<li>在阶段三中，如果参与者收到commit消息后，网络故障，这种情况，参与者仍会提交事务</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/23/jvm/" class="post-title-link" itemprop="url">jvm</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-23 20:54:31" itemprop="dateCreated datePublished" datetime="2018-08-23T20:54:31+08:00">2018-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span id="/2018/08/23/jvm/" class="post-meta-item leancloud_visitors" data-flag-title="jvm" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK版本</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><ul>
<li>swich可以支持字符串</li>
<li>创建泛型时类型自动推断</li>
</ul>
<h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><ul>
<li>Lambda表达式</li>
<li>函数式接口<ul>
<li>FunctionalInterface<ul>
<li><code>Consumer</code>接收一个参数，无返回结果</li>
<li><code>Function</code>接收一个参数，返回一个结果</li>
<li><code>Predicate</code>接收一个参数，返回要给boolean结果</li>
<li><code>Supplier</code>不接收参数，返回一个结果</li>
</ul>
</li>
</ul>
</li>
<li>接口默认方法</li>
<li>方法引用<ul>
<li>类名::静态方法名</li>
<li>引用名或对象名::实例方法名</li>
<li>类名::实例方法名</li>
<li>类名::new（构造方法引用）</li>
</ul>
</li>
<li>重复注解</li>
<li>工具类<ul>
<li>Optional</li>
<li>Instant</li>
<li>LocalDate</li>
<li>LocalTime</li>
<li>Duration</li>
<li>Streams</li>
</ul>
</li>
</ul>
<h2 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>启动类加载器<ul>
<li>环境变量：sun.boot.class.path</li>
<li>加载lib下面的jar包；环境变量目录下的jar包和class文件</li>
<li>将.class文件放入到环境遍变量对应的目录下，即可以使用该类加载器加载</li>
</ul>
</li>
<li>扩展类加载器<ul>
<li>环境变量：java.ext.dirs</li>
<li>加载lib&#x2F;ext下的jar包，只能加载jar包，不能加载单独的class</li>
<li>将jar包放入环境变量对应的目录下，既可使用该类加载器加载</li>
</ul>
</li>
<li>系统类加载器<ul>
<li>环境变量：java.class.path</li>
<li>加载环境变量对应目录下的jar包和class文件</li>
<li>可设置java.system.class.loader改变系统类加载器</li>
</ul>
</li>
<li>自定义类加载器<ul>
<li>继承ClassLoader<ul>
<li>重写findClass方法<ul>
<li>调用defineClass方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h3><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>当一个类加载器接收到类加载请求时，会先请求父类加载器去加载，如果所有的父类加载器都不能加载的时候，当前类加载器才会加载</p>
<ul>
<li><p>优点</p>
<ul>
<li>可以确保核心类库的安全性</li>
<li>可以确保Java核心类库的类不会被自定义类加载器加载</li>
<li>不同的类加载器可以为相同的类创建不同的命名空间</li>
</ul>
</li>
<li><p>规则</p>
<ul>
<li>父类加载器加载的类不能访问子类加载器加载的类</li>
<li>子类加载器加载的类可以访问父类加载器加载的类</li>
</ul>
</li>
<li><p>上下文类加载器</p>
<ul>
<li><p>打破了双亲委派模型规则</p>
</li>
<li><p>使用方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader();</span><br><span class="line">    <span class="comment">//具体业务逻辑实现</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展</p>
<ul>
<li>SPI<ul>
<li>Java定制的一套规范，各大厂商各自实现各自的业务</li>
<li>使用了上下文类加载器</li>
<li>JDBC&#x2F;JNDI等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><ul>
<li>首次主动使用<ul>
<li>创建一个实例</li>
<li>使用反射</li>
<li>调用类的静态方法或静态变量</li>
<li>为类的静态变量赋值</li>
<li>JVM启动时指定的类（包含main方法的类）</li>
<li>初始化一个子类，父类会被加载</li>
</ul>
</li>
</ul>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><ul>
<li>加载<ul>
<li>将class的二进制数据加载到内存中</li>
</ul>
</li>
<li>连接<ul>
<li>校验<ul>
<li>确保类的正确性<ul>
<li>类的文件结构检查</li>
<li>语义检查</li>
<li>字节码检查</li>
<li>二进制兼容性验证</li>
</ul>
</li>
</ul>
</li>
<li>准备<ul>
<li>为类的静态变量分配内存，并为其赋予初始值</li>
</ul>
</li>
<li>解析<ul>
<li>将类中的符号引用转换成直接引用<ul>
<li>符号引用<ul>
<li>在编译期间，Java类并不知道所引用的类的实际地址，因此只能使用符号代替</li>
</ul>
</li>
<li>直接引用<ul>
<li>直接指向目标的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>初始化<ul>
<li>为类的静态变量赋予真正的初始值</li>
</ul>
</li>
<li>使用</li>
<li>卸载<ul>
<li>在JVM运行中，系统自带的类加载器加载的类无法卸载</li>
<li>自定义的类加载器加载的类可以卸载</li>
</ul>
</li>
</ul>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>记录每个线程下一步执行的JVM指令</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>局部变量表<ul>
<li>一组变量值存储空间，存放方法参数和方法内部定义的局部变量</li>
</ul>
</li>
<li>动态链接<ul>
<li>字节码中的方法调用指令以常量池中指向方法的符号引用为参数<ul>
<li>这些符号引用一部分在每次运行期间转化为直接引用，这部分称为动态连接</li>
<li>另外一部分在类加载阶段或第一次使用的时候转化为直接引用，这种称为静态解析</li>
</ul>
</li>
</ul>
</li>
<li>操作数栈<ul>
<li>方法执行过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈和出栈操作（后入先出栈）</li>
</ul>
</li>
<li>方法出口<ul>
<li>方法完成出口</li>
<li>异常完成出口</li>
</ul>
</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>默认初始大小和最大大小：物理内存的1&#x2F;4</p>
<p>默认情况下，空余堆小于40%，JVM会增大堆内存到最大堆大小，空余堆大于70%，JVM会减少堆内存到初始堆大小</p>
<ul>
<li>数组</li>
<li>对象<ul>
<li>内存布局<ul>
<li>对象头<ul>
<li>MarkWord，用与存储对象自身的运行时数据，如哈希码&#x2F;GC分带年龄&#x2F;锁状态标志&#x2F;线程持有的锁&#x2F;偏向线程ID&#x2F;偏向时间等</li>
<li>klass，类型指针，即指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
</ul>
</li>
<li>实例数据<ul>
<li>对象真正存储的有效信息，程序代码中定义的各种类型的字段内容</li>
</ul>
</li>
<li>对齐填充<ul>
<li>不是必然存在的，占位符的作用</li>
<li>由于HotSpot VM的自动内存管理系统要求对象的大小必须是8字节的整数倍，如果对象实例数据部分没有对齐时，需要通过对齐填充来补全</li>
</ul>
</li>
</ul>
</li>
<li>内存分配<ul>
<li>分配方法<ul>
<li>指针碰撞<ul>
<li>Serial&#x2F;ParNew等带Compact过程的收集器（标记-整理算法）</li>
<li>假设Java堆中内存是绝对规整的，所有用的内存都放在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离</li>
</ul>
</li>
<li>空闲列表<ul>
<li>CMS这种基于Mark-Sweep算法的收集器（标记-清除算法）</li>
<li>如果Java堆中内存不是规整的，已使用的内存和空闲的内存相互交错，那么虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>
</ul>
</li>
</ul>
</li>
<li>分配类型<ul>
<li>栈上分配<ul>
<li>如果确定一个对象不会逃逸出方法之外，则可以让这个对象在栈上分配内存</li>
</ul>
</li>
<li>TLAB分配<ul>
<li>每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲</li>
</ul>
</li>
</ul>
</li>
<li>逃逸分析（当一个对象在方法中被定义后，它有可能被外部方法锁引用）<ul>
<li>方法逃逸<ul>
<li>比如作为调用参数传递到其他方法中</li>
</ul>
</li>
<li>线程逃逸<ul>
<li>有可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>JDK1.8使用元空间（MetaSpace）代替</p>
<p>默认初始大小：物理内存的1&#x2F;64</p>
<p>默认最大大小：物理内存的1&#x2F;4</p>
<ul>
<li>内中方法</li>
<li>静态变量</li>
<li>final常量</li>
<li>类信息</li>
</ul>
<h3 id="本地方法区"><a href="#本地方法区" class="headerlink" title="本地方法区"></a>本地方法区</h3><p>存放native方法</p>
<p>执行引擎</p>
<h3 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h3><h4 id="收集算法"><a href="#收集算法" class="headerlink" title="收集算法"></a>收集算法</h4><h5 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h5><ul>
<li>引用计数法<ul>
<li>给对象添加一个引用计数器，每当有一个地方引用该对象时，计数值+1，当该对象引用失效时，计数值-1，计数器值为0的对象则可以进行回收</li>
<li>无法检测出循环引用</li>
</ul>
</li>
<li>可达性分析算法<ul>
<li>从GCRoots根节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，则证明此对象不可用<ul>
<li>GCRoots<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区静态属性引用的对象</li>
<li>方法区常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="收集算法-1"><a href="#收集算法-1" class="headerlink" title="收集算法"></a>收集算法</h5><ul>
<li>复制算法<ul>
<li>将现有空间分为两块，每次只使用其中一块，垃圾回收时将正在使用的内存中存活的对象复制到未被使用的内存块中，之后清除正在使用的内存块中所有对象，然后交换两个内存块的角色</li>
<li>缺点<ul>
<li>浪费一半内存</li>
<li>如果所有对象都存活，那么复制效率低下</li>
</ul>
</li>
</ul>
</li>
<li>标记-清理算法<ul>
<li>过程<ul>
<li>标记阶段，遍历GC Roots，标记存活的对象</li>
<li>清除阶段，遍历堆中所有对象，清除未被标记的对象</li>
</ul>
</li>
<li>缺点<ul>
<li>效率低（递归与全堆对象遍历）</li>
<li>造成大量的空间碎片</li>
</ul>
</li>
</ul>
</li>
<li>标记-整理算法<ul>
<li>标记阶段，遍历GC Roots，标记存活的对象</li>
<li>整理阶段，移动所有存活对象，按照内存地址依次排序，然后将末端内存地址以后的内存全部回收</li>
</ul>
</li>
</ul>
<h4 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h4><ul>
<li>新生代（stop the world）<ul>
<li>Serial（串行收集器）采用复制算法</li>
<li>Parallel Scavenge（并行收集器）采用复制算法</li>
<li>ParNew（并行收集器）采用复制算法</li>
</ul>
</li>
<li>老年代<ul>
<li>Serial Old（串行收集器）标记-整理算法</li>
<li>Parallel Old（并行收集器）标记-整理算法</li>
<li>CMS（并发收集器）标记-清理算法<ul>
<li>标记-清除过程<ul>
<li>初始标记（Stop The World）<ul>
<li>标记被年轻代中存活对象引用的直接对象</li>
<li>标记老年代中所有GC Roots能直接关联到的对象</li>
</ul>
</li>
<li>并发标记<ul>
<li>从“初始标记”阶段标记的对象开始标记所有存活的对象</li>
</ul>
</li>
<li>重新标记（Stop The World）<ul>
<li>进行可达性分析，标记GCRoots能直接关联到的对象</li>
<li>可设置<code>-XX:CMSScavengeBeforeRemark</code>在标记前触发新生代GC</li>
</ul>
</li>
<li>并发清除<ul>
<li>清除没有标记的对象，并且回收空间</li>
</ul>
</li>
</ul>
</li>
<li>压缩策略（满足任意条件都会压缩）<ul>
<li>UseCMSCompactAtFullCollection为true和CMSFullGCsBeforeCompaction上一次GC执行过后，还需要多少次full gc才会做压缩，默认0。</li>
<li>用户调用System.gc()，而且DisableExplicitGC没有开启</li>
<li>新生代预计老年代没有足够空间来容纳下次新生代晋升的对象</li>
</ul>
</li>
<li>优点<ul>
<li>并发收集，低停顿</li>
</ul>
</li>
<li>缺点<ul>
<li>内存碎片；对CPU资源非常敏感；需要更大的堆；无法处理浮动垃圾</li>
</ul>
</li>
<li>常见问题<ul>
<li>promotion failed<ul>
<li>在Minor GC时，Survivor Space放不下对象只能进入老年代，而此时老年代也放不下造成的，多数是老年代没有足够的空闲空间，但是由于碎片多，没有连续的空闲空间</li>
<li>解决方法<ul>
<li>调大新生代或Survivor空间或者让CMS进行一定次数的Full GC的时候进行一次标记整理算法（-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction&#x3D;5）</li>
</ul>
</li>
</ul>
</li>
<li>concurrent mode failure<ul>
<li>在执行CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足，这时CMS还没有机会回收老年代产生的</li>
<li>在Minor GC的时候，Survivor放不下，需要放入老年代，而老年代也放不下产生的</li>
<li>如果对象分配率高于CMS回收的效率，将导致在CMS完成之前老年代就被填满</li>
<li>解决方法<ul>
<li>调低触发CMS GC执行的阈值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>整堆<ul>
<li>G1（并发收集器）标记-整理算法<ul>
<li>结构<ul>
<li>将堆分成多个大小相同的Region，默认2048个，在1-32M之间</li>
<li>每个Region的大小只能是2的幂次方，可通过-XX:G1HeapRegionSize指定大小</li>
<li>逻辑上分成Eden、Survivor、Old、Humongous（巨型）、空闲，大小不固定，根据每次GC的信息做出调整</li>
<li>新建对象超过Region大小的一半时，直接在一个Region或多个连续的Region中分配，并标记为Humongous</li>
<li>H-Object在Global Concurrent Marking阶段cleanup或Full GC阶段回收</li>
</ul>
</li>
<li>优点<ul>
<li>并行与并发</li>
<li>停顿时间可控，可配置预期停顿时间来控制GC时间，避免雪崩</li>
</ul>
</li>
<li>收集算法<ul>
<li>新生代采用复制算法</li>
<li>老年代采用标记-整理算法</li>
</ul>
</li>
<li>Young GC（STW）当所有Eden Region被耗尽无法申请内存时，就会触发一次Young GC</li>
<li>Mixed GC（回收一部分老年代）<ul>
<li>标记整理过程<ul>
<li>初始标记（STW）<ul>
<li>共用了Young GC的暂停，标记从GC Roots开始直接可达的对象</li>
</ul>
</li>
<li>扫描根引用区<ul>
<li>初始标记后，Eden区被清空，存活对象被移入Survivor区，在这阶段，将扫描由Survivor区直接可达的老年代区域，并标记存活对象</li>
<li>并发执行，不能和Young GC同时执行，如果此时由Young GC，则Young GC会暂停</li>
</ul>
</li>
<li>并发标记<ul>
<li>从GC Root开始对堆中的对象标记，标记线程与应用线程并行执行，并且收集各个Region的存活对象信息</li>
<li>可能被Young GC中断，如果发现Region中的所有对象都是垃圾，那么这个Region会被立即回收</li>
</ul>
</li>
<li>重新标记（STW）<ul>
<li>标记在“并发标记”阶段产生的新垃圾，使用SATB算法</li>
</ul>
</li>
<li>清除（STW）<ul>
<li>对存活的对象和完全空的区域进行统计（STW）</li>
<li>刷新Remembered Sets（STW）</li>
<li>重置空的区域，放到Free List</li>
</ul>
</li>
<li>复制（STW）<ul>
<li>将存活对象复制到未使用的区域中</li>
</ul>
</li>
</ul>
</li>
<li>使用-XX:InitiatingHeapOccupancyPercent设置Mixed GC的阈值，当老年代大小占整堆大小百分比达到阈值时，会触发一次Mixed GC</li>
</ul>
</li>
<li>Full GC<ul>
<li>如果对象内存分配速度过快，Mixed GC来不及回收，导致老年代被填满，就会触发一次Full GC<ul>
<li>解决方法：增加堆大小</li>
</ul>
</li>
<li>在进行GC的时候没有足够的内存供存活对象或晋升对象使用，就会触发Full GC<ul>
<li>解决方法<ul>
<li>增加-XX:G1ReservePercent选项的值，为“目标空间”增加预留内存地址</li>
<li>通过减少-XX:InitiatingHeadOccupancyPercent提前启动标记周期</li>
<li>增加-XX:ConcGCThreads选项的值来增加并行标记线程的数目</li>
</ul>
</li>
</ul>
</li>
<li>巨型对象找不到合适的空间进行分配时，就会触发Full GC<ul>
<li>解决方法<ul>
<li>增加堆大小</li>
<li>使用-XX:G1HeapRegionSize修改Region的大小，使巨型对象不再是巨型对象</li>
</ul>
</li>
</ul>
</li>
<li>G1的Full GC算法是单线程执行Serial Old过程，会导致长时间的暂停时间，需要进行不断的调优，尽可能的避免Full GC</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h4><ul>
<li>吞吐量<ul>
<li>应用系统的生命周期内，应用程序所花费的时间和系统总运行时间的比值</li>
<li>系统总运行时间 &#x3D; 应用程序耗时 + GC耗时</li>
<li>如果系统运行了100分钟，GC耗时1分钟，则系统吞吐量 &#x3D; 99%</li>
</ul>
</li>
<li>垃圾回收器负载<ul>
<li>GC耗时 &#x2F; 系统总运行时间</li>
</ul>
</li>
<li>停顿时间<ul>
<li>垃圾回收器运行时，应用程序的暂停时间</li>
</ul>
</li>
<li>垃圾回收频率<ul>
<li>垃圾回收器多长时间运行一次</li>
<li>一般而言，频率越低越好，通常增大堆空间可以有效降低垃圾回收发送的频率，但是会增加回收时产生的停顿时间</li>
</ul>
</li>
<li>反应时间<ul>
<li>当一个对象成为来及后，多长时间内，它所占用的内存空间会被释放掉</li>
</ul>
</li>
</ul>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul>
<li>过早提升<ul>
<li>在Minor GC过程中，Survivor UnUsed可能不足以容纳Eden和Survivor中存活的对象，那么多余的对象将被移到老年代，称为过早提升</li>
<li>Survivor空间太小，容纳不下全部运行时短生命周期的对象<ul>
<li>解决方法：调大Survivor空间</li>
</ul>
</li>
<li>对象太大，Survivor和Eden没有足够大的空间来存放这些对象</li>
</ul>
</li>
<li>提升失败<ul>
<li>过早提升会导致老年代中短期存活对象的增长，如果老年代满了，Minor GC后会进行Full GC，将导致遍历整个堆，称为提升失败</li>
<li>造成原因<ul>
<li>老年代空闲空间不够<ul>
<li>解决方法：将CMS触发的阈值调低</li>
</ul>
</li>
<li>老年代空闲空间多，但是碎片太多，没有连续的空闲空间存放对象<ul>
<li>解决方法：CMS需要进行空间整理压缩</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><h4 id="C1-编译器（Client-Compiler）"><a href="#C1-编译器（Client-Compiler）" class="headerlink" title="C1 编译器（Client Compiler）"></a>C1 编译器（Client Compiler）</h4><ul>
<li>方法内联</li>
<li>去虚拟化</li>
<li>冗余消除</li>
</ul>
<h4 id="C2-编译器（Server-Compiler）"><a href="#C2-编译器（Server-Compiler）" class="headerlink" title="C2 编译器（Server Compiler）"></a>C2 编译器（Server Compiler）</h4><ul>
<li>标量替换</li>
<li>栈上分配</li>
<li>同步消除</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul>
<li>偏向锁<ul>
<li>只有一个线程在访问，不存在多线程竞争的情况</li>
</ul>
</li>
<li>轻量级锁<ul>
<li>线程交替执行同步块的情况下使用轻量级锁</li>
</ul>
</li>
<li>重量级锁<ul>
<li>如果存在同一时间访问同一锁的情况，轻量级锁会膨胀为重量级锁</li>
<li>监视器锁，依赖底层操作系统Mutex Lock所实现的锁，用户态转换到核心态需要很长时间</li>
</ul>
</li>
<li>自旋锁<ul>
<li>让线程执行无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环；默认自旋10次</li>
<li>自适应自旋锁<ul>
<li>自旋锁的优化，自旋时间不固定，由前一次在同一锁上的自旋时间及锁的拥有者的状态来决定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>虚拟机探测到一串零碎的操作都对同一对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部</p>
<h3 id="锁削除"><a href="#锁削除" class="headerlink" title="锁削除"></a>锁削除</h3><p>虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行削除</p>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>堆参数<ul>
<li>-Xms&#96;设置初始堆大小</li>
<li><code>-Xmx</code>设置最大堆大小</li>
<li><code>-Xmn</code>设置年轻代大小</li>
<li><code>-Xss</code>设置线程堆栈大小<ul>
<li>Xss越大，每个线程的大小就越大，占用的内存就越多，能容纳的线程就越少</li>
<li>Xss越小，则递归的深度越小，容易出现栈溢出（StackOverflowError），减少局部变量的声明，可以节省栈帧大小，增加调用深度</li>
</ul>
</li>
<li><code>-XX:NewRatio=n</code>设置新生代和老年代比例<ul>
<li>如果n&#x3D;8，则新生代和老年代的比例1：8，新生代占比1&#x2F;9</li>
</ul>
</li>
<li><code>-XX:SurvivorRatio=n</code>设置新生代Eden和Survivor的比例<ul>
<li>新生代中有2个survivor区域，如果n&#x3D;8，则eden和survivor的比例8：2，一个survivor占新生代1&#x2F;10</li>
</ul>
</li>
<li><code>-XX:PermSize=n</code>设置方法区（持久代）初始大小</li>
<li><code>-XX:MaxPermSize=n</code>设置方法区（持久代）最大大小</li>
<li><code>-XX:TargetSurvivorRatio=n</code>目标存活率<ul>
<li>如果n&#x3D;50%，在survivor空间中相同年龄所有对象大小的总和大于50%时，年龄大于等于该年龄的对象就可以直接进入老年代</li>
</ul>
</li>
<li><code>-XX:MaxTenuringThreshold=n</code>设置对象在新生代中survivor存活的年龄<ul>
<li>默认15，如果n&#x3D;13，则新生代gc13次之后，对象会从新生代survivor中晋升到老年代</li>
</ul>
</li>
</ul>
</li>
<li>收集器参数<ul>
<li><code>-XX:+UseSerialGC</code>（Serial + Serial Old）</li>
<li><code>-XX:+UseParallelGC</code>（Parallel Scavenge + Parallel Old）</li>
<li><code>-XX:+UseParNewGC</code>（ParNew + Serial Old）</li>
<li><code>-XX:+UseParallelOldGC（JDK1.5后失效）</code>（Parallel Scavenge + Parallel Old）</li>
<li><code>-XX:+UseConcMarkSweepGC</code>（ParNew + CMS）</li>
</ul>
</li>
<li>并行参数<ul>
<li><code>-XX:ParallelGCThreads=n</code>设置并行收集器并行收集线程数</li>
<li><code>-XX:MaxGCPauseMillis=n</code>设置每次年轻的垃圾回收最长时间（最大暂停时间）</li>
<li><code>-XX:GCTimeRatio=n</code>设置垃圾回收时间占程序运行时间的百分比</li>
</ul>
</li>
<li>并发参数<ul>
<li><code>-XX:+CMSIncrementalMode</code>设置为增量模式，适用于单CPU环境</li>
<li><code>-XX:ParallelGCThreads=n</code>设置并发收集器年轻代收集为并行收集器时，并行收集线程数</li>
</ul>
</li>
<li>统计参数设置<ul>
<li><code>-XX:+PrintGC</code>打印GC信息</li>
<li><code>-XX:+PrintGCDetails</code>打印GC信息</li>
<li><code>-XX:+PrintGCTimeStamps</code>打印GC信息</li>
<li><code>-XX:+PrintHeapAtGC</code>打印GC前后的详细堆栈信息</li>
<li><code>-Xloggc:filename</code>将日志信息记录到文件中</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/16/juc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/16/juc/" class="post-title-link" itemprop="url">juc并发包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-16 20:52:41" itemprop="dateCreated datePublished" datetime="2018-08-16T20:52:41+08:00">2018-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span id="/2018/08/16/juc/" class="post-meta-item leancloud_visitors" data-flag-title="juc并发包" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul>
<li>基于AQS实现</li>
<li>乐观锁</li>
<li>可中断</li>
<li>支持公平锁和非公平锁</li>
<li>可以判断锁状态</li>
</ul>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><ul>
<li>类似ReentrantLock</li>
<li>readLock，读锁，共享锁<ul>
<li>没有其他线程的写锁</li>
<li>没有写请求</li>
<li>有写请求，但调用线程和持有锁的线程是同一个</li>
</ul>
</li>
<li>writeLock，写锁，独占锁<ul>
<li>没有其他线程的读锁</li>
<li>没有其他线程的写锁</li>
</ul>
</li>
</ul>
<h3 id="同步设备"><a href="#同步设备" class="headerlink" title="同步设备"></a>同步设备</h3><h4 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h4><ul>
<li>同步队列器</li>
<li>提供了一个FIFO双向队列</li>
<li>通过UnSafe操作</li>
</ul>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><ul>
<li>允许一个或多个线程等待其他线程完成操作</li>
<li>内部采用AbstractQueuedSynchronizer的共享锁</li>
<li>采用减计数方式，计数为0时是否所有等待的线程，当计数为0时，计数无法重置，每次调用countDown计数减1，调用await值进行阻塞对计数无影响</li>
</ul>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><ul>
<li>可循环使用的屏障</li>
<li>让一组线程到达一个屏障时阻塞，直到最后一个线程到达屏障时，所有被屏障拦截的线程才会继续执行</li>
<li>内部采用ReentrantLock实现</li>
<li>采用加计数方式，计数达到指定值时释放所有等待的线程，计数重置为0重新开始，每次调用await计数加1，若计数不等于指定值，则线程阻塞</li>
</ul>
<h4 id="Semphore"><a href="#Semphore" class="headerlink" title="Semphore"></a>Semphore</h4><ul>
<li>信号量，控制同时访问特定资源的线程数量</li>
<li>内部实现AbstractQueuedSynchronizer的共享锁</li>
<li>通过acquire获取一个许可，如果没有就阻塞等待，通过release释放一个许可</li>
</ul>
<h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><ul>
<li>交换者，用于线程间的数据交换，它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据</li>
</ul>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul>
<li>默认容量为16，默认并发度16，按照2的幂次方扩容，不能插入key为null和value为null的元素</li>
<li>JDK1.7<ul>
<li>分段锁Segment+HashEntry</li>
<li>size方法<ul>
<li>先采用不加锁的方式，连续计算元素的个数，最多计算3次，如果前两次计算结果相同，则说明计算出来的元素个数准确；如果不相同，则给每个Segment进行加锁，再计算一次元素的个数</li>
</ul>
</li>
</ul>
</li>
<li>JDK1.8<ul>
<li>Node+CAS+synchronized</li>
<li>size方法<ul>
<li>使用volatile类型的变量baseCount记录元素个数，通过addCount()更新baseCount；baseCount+counterCells遍历的value</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul>
<li>AtomicInteger</li>
<li>AtomicLong</li>
<li>AtomicBoolean</li>
</ul>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
</ul>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul>
<li>AtomicReference</li>
<li>AtomicReferenceArray</li>
<li>AtomicReferenceFieldUpdater</li>
<li>AtomicMarkableReference</li>
</ul>
<h4 id="字段类"><a href="#字段类" class="headerlink" title="字段类"></a>字段类</h4><ul>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
<li>AtomicStampedReference</li>
</ul>
<h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h3><p>用于并行执行任务的框架，Fork把一个大任务切分若干个子任务并行的执行，Join合并这些子任务的执行结果，最后得到这个大任务的结果</p>
<ul>
<li><p>ForkJoinPool</p>
<p>ForkJoin框架的任务池，ExecuteService的实现类</p>
</li>
<li><p>ForkJoinTask</p>
<ul>
<li>Future的子类，框架任务的抽象</li>
<li><code>RecursiveAction</code> ForkJoinTask的子类，用于没有返回结果的任务</li>
<li><code>RecursiveTask</code> ForkJoinTask的子类，用于有返回结果的任务</li>
</ul>
</li>
<li><p><code>ForkJoinWorkerThread</code>工作线程</p>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><ul>
<li>newFixedThreadPool<ul>
<li>初始化一个核心线程数和最大线程数相同的线程池</li>
<li>内部使用LinkedBlockingQueue作为阻塞队列</li>
</ul>
</li>
<li>newSingleThreadExecutor<ul>
<li>初始化只有一个线程的线程池，如果该线程异常结束，会重新开始一个新的线程继续执行任务，可以保证任务提交的顺序</li>
<li>内部使用LinkedBlockingQueue作为阻塞队列</li>
</ul>
</li>
<li>newCachedThreadPool<ul>
<li>初始化一个可缓存线程的线程池，默认60s</li>
<li>内部使用SynchronousQueue作为阻塞队列</li>
</ul>
</li>
<li>newScheduledThreadPool<ul>
<li>初始化可以在指定时间内周期性的执行所提交的任务</li>
<li>内部使用DelayedWorkQueue作为阻塞队列</li>
</ul>
</li>
</ul>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><ul>
<li><code>corePoolSize</code>核心线程池大小</li>
<li><code>maximumPoolSize</code>最大线程池大小</li>
<li><code>keepAliveTime</code>线程池中超过corePoolSize数目的空闲线程最大存活时间</li>
<li><code>TimeUnit</code>keepAliveTime的时间单位</li>
<li><code>workQueue</code>阻塞任务队列<ul>
<li><code>ArrayBlockingQueue</code>基于数组的有界阻塞队列，FIFO</li>
<li><code>LinkedBlockingQueue</code>基于链表的有界阻塞队列，FIFO，吞吐量高于ArrayBlockingQueue</li>
<li><code>SynchronousQueue</code>不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则一直阻塞，吞吐量通常高于LinkedBlockingQueue</li>
<li><code>PriorityBlockQueue</code>具有优先级的无界阻塞队列</li>
<li><code>DelayQueue</code>支持延时获取元素的无界阻塞队列</li>
</ul>
</li>
<li><code>RejectedExecutionHandler</code>任务丢弃策略<ul>
<li>AbortPolicy（丢弃任务，抛运行时异常）</li>
<li>CallerRunsPolicy（执行任务）</li>
<li>DiscardPolicy（忽略）</li>
<li>DiscardOldestPolicy（从队列中踢出最先进入队列的任务）</li>
</ul>
</li>
<li>threadFactory</li>
</ul>
<h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul>
<li><code>Running</code>线程创建后，初始时，处于Running状态</li>
<li><code>Shutdown</code>调用了shtudown方法，处于shutdown状态，线程池不能接收新的任务，等待所有任务执行完成</li>
<li><code>Stop</code>调用了shotdownNow方法，处于stop状态，线程池不能接收新的任务，并且尝试终止正在执行的任务</li>
<li><code>Terminated</code>当线程池处于shutdown和stop状态，并且所有工作线程已经销毁，任务缓存队列已经清空和执行结束后，线程池被置为Terminated状态</li>
</ul>
<h4 id="线程数"><a href="#线程数" class="headerlink" title="线程数"></a>线程数</h4><ul>
<li>通用配置<ul>
<li>CPU密集型（CPU数目 + 1）</li>
<li>IO密集型（2 * CPU数目 + 1）</li>
</ul>
</li>
<li>最佳配置<ul>
<li>((线程等待时间 + 线程CPU时间) &#x2F; 线程CPU时间）* CPU数目</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李波">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李波的博客">
      <meta itemprop="description" content="读万卷书，更要行万里路！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 李波的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/12/zookeeper/" class="post-title-link" itemprop="url">zookeeper（分布式协调服务）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-12 16:06:30" itemprop="dateCreated datePublished" datetime="2018-08-12T16:06:30+08:00">2018-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-31 11:16:37" itemprop="dateModified" datetime="2024-07-31T11:16:37+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
    </span>

  
    <span id="/2018/08/12/zookeeper/" class="post-meta-item leancloud_visitors" data-flag-title="zookeeper（分布式协调服务）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ul>
<li>防止单点故障</li>
<li>节点数据一致性</li>
<li>数据恢复</li>
<li>顺序访问</li>
<li>高性能</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>分布式锁、负载均衡、注册中心、配置中心</li>
</ul>
<h3 id="zoo-cnf配置详解"><a href="#zoo-cnf配置详解" class="headerlink" title="zoo.cnf配置详解"></a>zoo.cnf配置详解</h3><ul>
<li>tickTime 心跳时间间隔</li>
<li>initLimit 客户端初始化连接最长多少个tickTime</li>
<li>syncLimit leader和follower之间发送消息，请求和应答时间最长多少个tickTime</li>
<li>端口 2181（客户端提供服务）、2888（集群通信端口）:3888（leader选举端口）</li>
</ul>
<h3 id="节点特性"><a href="#节点特性" class="headerlink" title="节点特性"></a>节点特性</h3><ul>
<li>持久节点、持久有序节点、临时节点、临时有序节点</li>
<li>临时节点和临时有序节点不能有子节点</li>
<li>同级节点唯一</li>
</ul>
<h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><h4 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h4><ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各服务器的调度者</li>
</ul>
<h4 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h4><ul>
<li>处理客户端非事务请求、转发事务请求给leader</li>
<li>参与事务请求proposal（提案）的投票</li>
<li>参与leader选举的投票</li>
</ul>
<h4 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h4><ul>
<li>提供非事务请求服务</li>
</ul>
<h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><h4 id="选举状态"><a href="#选举状态" class="headerlink" title="选举状态"></a>选举状态</h4><ul>
<li>LOOKING（初始启动，默认都是LOOKING）</li>
<li>LEADING</li>
<li>FOLLOWING</li>
<li>OBSERVING</li>
</ul>
<h4 id="选举参数"><a href="#选举参数" class="headerlink" title="选举参数"></a>选举参数</h4><ul>
<li>zxid（最大会设置成leader，事务ID越大，表示数据越新）64位<ul>
<li>前32位是<strong>epoch</strong>编号，每一轮投票，epoch都会递增，每产生一个新的leader，那么新的leader的epoch会+1</li>
<li>后32位消息计数器（自增），每接收一条消息+1，新leader选举后重置为0</li>
</ul>
</li>
<li>myid（myid越大，在leader选举机制中权重越大）</li>
</ul>
<h4 id="选举时机"><a href="#选举时机" class="headerlink" title="选举时机"></a>选举时机</h4><ul>
<li>启动时leader选举</li>
<li>leader崩溃时选举</li>
</ul>
<h3 id="ZAB协议（基于paxos理论）"><a href="#ZAB协议（基于paxos理论）" class="headerlink" title="ZAB协议（基于paxos理论）"></a>ZAB协议（基于paxos理论）</h3><p>Zookeeper Atomic Broadcast</p>
<p>支持崩溃恢复的原子广播协议、主要用于实现数据一致性</p>
<h4 id="原子广播（事务提交，改进版本的2PC）"><a href="#原子广播（事务提交，改进版本的2PC）" class="headerlink" title="原子广播（事务提交，改进版本的2PC）"></a>原子广播（事务提交，改进版本的2PC）</h4><ol>
<li>leader接收到消息请求后，将消息赋予一个全局唯一的64位自增ID，叫zxid</li>
<li>leader为每个follower准备了一个FIFO队列，将带有zxid的消息作为一个proposal提案分发给所有的follower</li>
<li>当follower接收到proposal，先把proposal写到磁盘，写入成功以后再向leader回复一个ack</li>
<li>当leader接收到合法数量（超过半数节点）的ack后，leader就会向这些follower发送commit命令，同时会再本地执行该消息</li>
<li>当follower收到消息的commit命令以后，会提交该消息</li>
</ol>
<h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><ol>
<li>当leader失去了过半的follower节点的连续</li>
<li>当leader服务挂了</li>
</ol>
<p>集群就会进入崩溃恢复阶段，对于数据恢复来说：</p>
<ol>
<li><p>已经被处理的消息不能丢失</p>
<p>当leader收到合法数量的follower的ack之后，就会向各个follower广播消息（commit命令）同时自己也会commit这条事务消息，如果follower节点收到commit命令之前，leader挂了，会导致部分节点收到commit，部分节点没有收到，那么zab协议需要保证已经被处理的消息不能丢失。</p>
</li>
<li><p>被丢弃的消息不能再次出现</p>
<p>当leader收到事务请求，并且还未发起事务投票之前，leader挂了，此次消息必须全部丢失</p>
</li>
</ol>
<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><h4 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h4><ul>
<li>world（所有人都能访问）</li>
<li>auth（不使用任何id，代表任何已认证的用户）</li>
<li>digest（用户名和密码验证）</li>
<li>ip（ip验证，格式addr&#x2F;bits）</li>
</ul>
<h4 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h4><ul>
<li>CREATE（创建权限，可以创建子节点，create，exists，getChildren，delete）</li>
<li>DELETE （删除权限，可以删除子节点，create，exists，getChildren，delete）</li>
<li>READ （读权限，可以获取节点和子节点列表，create，exists，getData，getChildren，delete）</li>
<li>WRITE （写权限，create，exists，getChildren，setData，delete）</li>
<li>ADMIN （管理权限，create，exists，getChildren，delete）</li>
</ul>
<h3 id="Watch机制"><a href="#Watch机制" class="headerlink" title="Watch机制"></a>Watch机制</h3><h4 id="watcher特性"><a href="#watcher特性" class="headerlink" title="watcher特性"></a>watcher特性</h4><ul>
<li>watcher是一次性的操作<ul>
<li>当数据发生变化时，zookeeper会产生一个watcher事件，并且会发送到客户端，但是客户端只会收到一次通知。如果后续这个节点再次发生变化，那么之前设置watcher的客户端不会再次收到消息。</li>
</ul>
</li>
<li>可以通过循环监听达到永久监听效果</li>
</ul>
<h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><ul>
<li>None 客户端连接状态发生变化的时候，会收到none的事件</li>
<li>NodeCreated 创建节点事件</li>
<li>NodeDeleted 删除节点事件</li>
<li>NodeDataChanged 节点数据发生变更</li>
<li>NodeChildrenChanged 子节点被创建、删除会发生</li>
</ul>
<h4 id="如何注册事件机制"><a href="#如何注册事件机制" class="headerlink" title="如何注册事件机制"></a>如何注册事件机制</h4><ul>
<li>绑定事件<ul>
<li>getData、Exists、getChildren</li>
</ul>
</li>
<li>触发事件<ul>
<li>create、delete、setData</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李波</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlZTkyMTM=" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  






  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"qgDJa5iQHN6gyfPxvMNSkEl2-MdYXbMMI","app_key":"lzeNkGlIR6kknSYtOXkPhUAG","server_url":"https://qgdja5iq.api.lncldglobal.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"http://yoursite.com/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"lee9213","repo":"blog-common-log","client_id":"Ov23liRhRq195JbLB8GO","client_secret":"d8f3efcc7511d7aad6941e8cda1d1d764c1a6d56","admin_user":"lee9213","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
