<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李波的博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-07-31T03:16:37.262Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李波</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能调优</title>
    <link href="http://yoursite.com/2018/09/10/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2018/09/10/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2018-09-10T13:07:37.000Z</published>
    <updated>2024-07-31T03:16:37.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>P</code> 按照CPU占用降序排序</li><li><code>M</code> 按照内存占用降序排序</li><li><code>T</code> 按照运行时间降序排序</li><li><code>N</code> 按照PID降序排序</li><li><code>H</code> 进程和线程之间切换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">列名    含义</span><br><span class="line">PID    进程id</span><br><span class="line">PPID    父进程id</span><br><span class="line">RUSER    Realusername</span><br><span class="line">UID    进程所有者的用户id</span><br><span class="line">USER    进程所有者的用户名</span><br><span class="line">GROUP    进程所有者的组名</span><br><span class="line">TTY    启动进程的终端名。不是从终端启动的进程则显示为?</span><br><span class="line">PR       优先级</span><br><span class="line">NInice     值。负值表示高优先级，正值表示低优先级</span><br><span class="line">P        最后使用的CPU，仅在多CPU环境下有意义</span><br><span class="line">%CPU    上次更新到现在的CPU时间占用百分比</span><br><span class="line">TIME    进程使用的CPU时间总计，单位秒</span><br><span class="line">TIME+    进程使用的CPU时间总计，单位1/100秒</span><br><span class="line">%MEM    进程使用的物理内存百分比</span><br><span class="line">VIRT    进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line">SWAP    进程使用的虚拟内存中，被换出的大小，单位kb。</span><br><span class="line">RES    进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class="line">CODE    可执行代码占用的物理内存大小，单位kb</span><br><span class="line">DATA    可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</span><br><span class="line">SHR    共享内存大小，单位kb</span><br><span class="line">nFLT    页面错误次数</span><br><span class="line">nDRT    最后一次写入到现在，被修改过的页面数。</span><br><span class="line">S    进程状态。</span><br><span class="line">D=    不可中断的睡眠状态</span><br><span class="line">R=    运行</span><br><span class="line">S=    睡眠</span><br><span class="line">T=    跟踪/停止</span><br><span class="line">Z=    僵尸进程</span><br><span class="line">COMMAND    命令名/命令行</span><br><span class="line">WCHAN    若该进程在睡眠，则显示睡眠中的系统函数名</span><br></pre></td></tr></table></figure><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>查看io信息，对系统的磁盘操作活动进行监视，如<code>iostat -xd 1</code></p><h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-c 显示CPU使用情况</span><br><span class="line">-d 显示磁盘使用情况</span><br><span class="line">-k 以 KB 为单位显示</span><br><span class="line">-m 以 M 为单位显示</span><br><span class="line">-N 显示磁盘阵列(LVM) 信息</span><br><span class="line">-n 显示NFS 使用情况</span><br><span class="line">-p[磁盘] 显示磁盘和分区的情况</span><br><span class="line">-t 显示终端和CPU的信息</span><br><span class="line">-x 显示详细信息</span><br><span class="line">-V 显示版本信息</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>可以显示当前系统未使用的和已使用的内存数目</p><h3 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>-b</code>(Byte)、<code>-k</code>(KB)、<code>-m</code>(MB)、<code>-o</code>(不显示缓冲区调节列)、</li></ul><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>显示虚拟内存状态（“Viryual Memor Statics”）</p><h3 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-a：显示活动内页；</span><br><span class="line">-f：显示启动后创建的进程总数；</span><br><span class="line">-m：显示slab信息；</span><br><span class="line">-n：头信息仅显示一次；</span><br><span class="line">-s：以表格方式显示事件计数器和内存状态；</span><br><span class="line">-d：报告磁盘状态；</span><br><span class="line">-p：显示指定的硬盘分区状态；</span><br><span class="line">-S：输出信息的单位</span><br></pre></td></tr></table></figure><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><p>jstat -gcutil [pid]</p><h2 id="nicstat"><a href="#nicstat" class="headerlink" title="nicstat"></a>nicstat</h2><h2 id="查看线程占用cpu"><a href="#查看线程占用cpu" class="headerlink" title="查看线程占用cpu"></a>查看线程占用cpu</h2><ul><li><code>top</code> 查看对应java程序的进程ID</li><li><code>jstack [pid] &gt; stack.txt</code> 使用jstack将堆栈导出</li><li><code>top -H</code> 查看对应java程序的线程ID</li><li><code>printf &quot;%x \n&quot; [线程ID] </code> 将10进制的线程ID转成16进制的线程ID</li><li>在之前导出的stack.txt文件中即可找到对应线程ID的线程</li></ul><h2 id="监控软件"><a href="#监控软件" class="headerlink" title="监控软件"></a>监控软件</h2><ul><li>zipkin</li><li>cat</li><li>zabbix nagios</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;top&quot;&gt;&lt;a href=&quot;#top&quot; class=&quot;headerlink&quot; title=&quot;top&quot;&gt;&lt;/a&gt;top&lt;/h2&gt;&lt;h3 id=&quot;常用参数&quot;&gt;&lt;a href=&quot;#常用参数&quot; class=&quot;headerlink&quot; title=&quot;常用参数&quot;&gt;&lt;/a&gt;常用参</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="http://yoursite.com/2018/09/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/09/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2018-09-05T13:06:40.000Z</published>
    <updated>2024-07-31T03:16:37.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统架构问题"><a href="#传统架构问题" class="headerlink" title="传统架构问题"></a>传统架构问题</h3><ul><li>系统资源浪费（水平扩展需要扩展整个应用，不能扩展单个模块）</li><li>部署效率低（修改了一行代码，需要部署整个应用）</li><li>技术选型单一</li></ul><h3 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h3><ul><li>微小度颗粒（细粒度）</li><li>服务单一简单（责任单一性），易于开发、理解和维护</li><li>运行隔离性，独立部署</li><li>管理自动化</li><li>扩展性高</li><li>服务内部高内聚、低耦合</li></ul><h3 id="微服务面临挑战"><a href="#微服务面临挑战" class="headerlink" title="微服务面临挑战"></a>微服务面临挑战</h3><ul><li>运维成本高</li><li>代码重复</li><li>分布式系统复杂性（网络延迟、系统容错、分布式事务）</li><li>部署依赖强（服务调用顺序）</li><li>通信成本高</li></ul><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>根据业务模块划分服务种类（垂直拆分）</li><li>每个服务可独立部署且相互隔离</li><li>通过轻量级API调用服务（Http或RMI）</li><li>服务需要保证良好的高可用性</li></ul><h4 id="交付流程"><a href="#交付流程" class="headerlink" title="交付流程"></a>交付流程</h4><ul><li>Design<ul><li>功能拆分，设计API接口，给出API文档</li></ul></li><li>Develop<ul><li>实现API接口，API单元测试</li></ul></li><li>Test<ul><li>测试环境，针对测试用例进行手工或自动化测试</li><li>预上线环境，冒烟测试</li><li>生产环境</li></ul></li><li>Deploy</li></ul><h4 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h4><h5 id="分支要求"><a href="#分支要求" class="headerlink" title="分支要求"></a>分支要求</h5><ul><li>master分支拉一个develop分支</li><li>开发功能时，从develop分支拉一个feature分支，如果多个功能就拉多个分支</li><li>当feature开发完成后，从develop分支上拉一个release分支</li><li>将所有feature分支合并到release分支上，对release分支部署测试环境，进行功能测试</li><li>如果有bug则在release分支上修改，等到无bug时，将release分支部署到预上线环境，再次验证</li><li>如果无bug则将release分支部署到生产环境中，待上线完成后，将release分支合并到develop分支和master分支</li><li>并且在master分支上打一个tag</li><li>如果生产环境有bug，则从对应的tag上拉一个hotfix分支，并在该分支上进行bug修复</li><li>待bug修复完成之后，将hotfix分支上的代码合并到develop分支和master分支</li></ul><h5 id="版本号的要求"><a href="#版本号的要求" class="headerlink" title="版本号的要求"></a>版本号的要求</h5><ul><li>格式为x.y.z<ul><li>x用于有重大重构时升级</li><li>y用于有新特性发布时才会升级</li><li>z用于修改了某个bug后才会升级</li></ul></li></ul><h4 id="微服务架构模式"><a href="#微服务架构模式" class="headerlink" title="微服务架构模式"></a>微服务架构模式</h4><ul><li>核心模式</li><li>部署模式</li><li>通信模式</li><li>服务发现模式</li><li>数据管理模式</li></ul><h3 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h3><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>Json Web Tokens，一种易于使用、无状态的鉴权方式</p><h3 id="RESTFul-API"><a href="#RESTFul-API" class="headerlink" title="RESTFul API"></a>RESTFul API</h3><ul><li>幂等<ul><li>GET</li><li>PUT</li><li>DELETE</li></ul></li><li>非幂等<ul><li>POST</li><li>PATCH</li></ul></li></ul><h3 id="如何保证接口的幂等性"><a href="#如何保证接口的幂等性" class="headerlink" title="如何保证接口的幂等性"></a>如何保证接口的幂等性</h3><ul><li>全局ID</li><li>版本号控制</li><li>状态机控制</li></ul><h3 id="最终一致性的实现方案"><a href="#最终一致性的实现方案" class="headerlink" title="最终一致性的实现方案"></a>最终一致性的实现方案</h3><ul><li>同步写</li><li>异步MQ同步</li><li>日志同步</li></ul><h3 id="如何应对微服务的链式调用异常"><a href="#如何应对微服务的链式调用异常" class="headerlink" title="如何应对微服务的链式调用异常"></a>如何应对微服务的链式调用异常</h3><ul><li>MQ解耦</li><li>Hystrix熔断</li><li>Sleuth+Zipkin链路追踪</li></ul><h3 id="如何保证微服务的安全-认证"><a href="#如何保证微服务的安全-认证" class="headerlink" title="如何保证微服务的安全&#x2F;认证"></a>如何保证微服务的安全&#x2F;认证</h3><ul><li>单点登陆</li><li>分布式session</li><li>客户端token（JWT、OAuth2.0）</li><li>客户端token和API网关结合</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;传统架构问题&quot;&gt;&lt;a href=&quot;#传统架构问题&quot; class=&quot;headerlink&quot; title=&quot;传统架构问题&quot;&gt;&lt;/a&gt;传统架构问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;系统资源浪费（水平扩展需要扩展整个应用，不能扩展单个模块）&lt;/li&gt;
&lt;li&gt;部署效率低（修改了</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yoursite.com/2018/09/01/thread/"/>
    <id>http://yoursite.com/2018/09/01/thread/</id>
    <published>2018-09-01T13:04:48.000Z</published>
    <updated>2024-07-31T03:16:37.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程使用场景"><a href="#多线程使用场景" class="headerlink" title="多线程使用场景"></a>多线程使用场景</h3><ul><li>通过并行计算提高程序执行性能</li><li>需要等待网络、I&#x2F;O响应导致耗费大量的执行时间，可以采用异步线程的方式来减少阻塞</li></ul><h3 id="如何应用多线程"><a href="#如何应用多线程" class="headerlink" title="如何应用多线程"></a>如何应用多线程</h3><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>使用ExecutorService、Callable、Future实现带返回结果的多线程</li></ul><h3 id="线程的状态（6种）"><a href="#线程的状态（6种）" class="headerlink" title="线程的状态（6种）"></a>线程的状态（6种）</h3><ul><li><p>NEW：初始状态，线程被构建，还没有调用start方法。</p></li><li><p>RUNNABLED：运行状态，Java线程把操作系统中的就绪和运行两种状态同一为“运行中”。</p></li><li><p>BLOCKED：阻塞状态，表示线程进入等待状态，也就是线程因为某种原因放弃了CPU使用权。</p><ul><li>等待阻塞：运行的线程执行wait方法，JVM会把当前线程放入等待队列</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程占用，那JVM会把当前的线程放入到锁池中</li><li>其他阻塞：运行的线程执行<code>Thread.sleep</code>或者<code>t.join</code>方法，或者发出了I&#x2F;O请求时，JVM会把当前线程设置为阻塞状态，当sleep结束、join线程终止、I&#x2F;O处理完毕则线程恢复</li></ul></li><li><p>WAITING：等待状态，运行的线程执行以下方法，当前线程会进入等待状态</p><ul><li><code>Object.wait</code></li><li><code>Object.join</code></li><li><code>LockSupport.park</code></li></ul></li><li><p>TIME_WAITING：超时等待状态，运行的线程执行以下方法，当前线程会进入超时等待状态</p><ul><li><code>Thread.sleep</code></li><li><code>Object.wait with timeout</code></li><li><code>Thread.join with timeout</code></li><li><code>LockSupport.parkNanos</code></li><li><code>LockSupport.parkUntil</code></li></ul></li></ul><p>TER</p><ul><li>TERMINATED：终止状态，表示当前线程执行完毕</li></ul><h3 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h3><ul><li>isInterrupted：默认情况下，在通过调用线程对象的isInterrupted方法返回false</li><li>interrupt：线程中断，调用线程对象的interrupt方法之后，再通过调用线程对象的isInterrupted方法返回true</li><li>interrupted ：线程复位，调用Thread.interrupted 方法之后，再通过调用线程对象的isInterrupted方法返回false</li></ul><h3 id="线程的停止"><a href="#线程的停止" class="headerlink" title="线程的停止"></a>线程的停止</h3><ul><li>通过interrupt方法实现中断线程</li><li>通过volatile共享变量实现中断线程</li></ul><h3 id="线程复位"><a href="#线程复位" class="headerlink" title="线程复位"></a>线程复位</h3><p>线程复位就是将调用线程的isInterrupted方法返回设置为false</p><ul><li>调用Thread.interrupted</li><li>抛出InterruptedException异常，JVM会把线程的中断标识位清除</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>可重入锁（递归锁，当一个线程获得了当前实例的锁，并进入方法A，这个线程在没有释放这把锁的情况下，可以再次进入方法A（递归））<ul><li>ReentrantLock<ul><li>乐观锁</li><li>可中断</li><li>公平锁和非公平锁</li><li>可以判断锁状态</li></ul></li><li>synchronized<ul><li>重量级锁&#x2F;监视器锁</li><li>CPU悲观锁机制</li><li>不可中断</li><li>非公平</li><li>不能判断锁状态</li></ul></li></ul></li><li>wait&#x2F;nofity&#x2F;notifyAll</li></ul><h3 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h3><ul><li><p>程序顺序规则</p><p>一个线程中的每个操作，happens-before于随后该线程中的任意后续操作</p></li><li><p>监视器锁规则</p><p>对一个锁的解锁，happens-before于随后对这个锁的获取</p></li><li><p>volatile变量规则</p><p>对一个volatile域的写，happens-bofore于对这个变量的读</p></li><li><p>传递性</p><p>如果A happens-bofore B，B happens-bofore C，那么A happens-bofore C</p></li><li><p>start规则</p><p>如果线程A执行线程B的start方法，那么线程A的ThreadB.start happens-bofore于线程B的任意操作</p></li><li><p>join规则</p><p>如果线程A执行线程B的join方法，那么线程B的任意操作happens-bofore于线程A从ThreadB.join方法成功返回</p></li></ul><h3 id="线程安全性问题"><a href="#线程安全性问题" class="headerlink" title="线程安全性问题"></a>线程安全性问题</h3><h4 id="CPU高速缓存"><a href="#CPU高速缓存" class="headerlink" title="CPU高速缓存"></a>CPU高速缓存</h4><p>高速缓存从下到上越接近 CPU 速度越快，同时容量也越小。缓存又可以分为指令缓存和数据缓存，指令缓存用来缓存程序的代码，数据缓存用来缓存程序的数据。高速缓存分为：</p><ul><li>L1 Cache，一级缓存，本地 core 的缓存，分成 32K 的数据缓存 L1d 和 32k 指令缓存 L1i，访问 L1 需要 3cycles，耗时大约 1ns； </li><li>L2 Cache，二级缓存，本地 core 的缓存，被设计为 L1 缓存与共享的 L3 缓存之间的缓冲，大小为 256K，访问 L2 需要 12cycles，耗时大约 3ns； </li><li>L3 Cache，三级缓存，在同插槽的所有 core 共享 L3 缓存，分为多个 2M 的段，访问 L3 需要 38cycles，耗时大约 12ns；</li></ul><h4 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h4><h5 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h5><p>当一个 CPU 对其缓存中的数据进行操作的时候，往总线中发送一个 Lock 信号。其他处理器的请求将会被阻塞，那么该处理器可以独占共享内存。总线锁相当于把 CPU 和内存之间的通信锁住了，所以这种方式会导致 CPU 的性能下降，所以 P6 系列以后的处理器，出现了另外一种方式，就是缓存锁。 </p><h5 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h5><p>如果缓存在处理器缓存行中的内存区域在 LOCK 操作期间被锁定，当它执行锁操作回写内存时，处理不在总线上声明 LOCK 信号，而是修改内部的缓存地址，然后通过缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻 止同时修改被两个以上处理器缓存的内存区域的数据，当其他处理器回写已经被锁定的缓存行的数据时会导致该缓存行无效。 所以如果声明了 CPU 的锁机制，会生成一个 LOCK 指令，会产生两个作用 </p><ol><li>Lock 前缀指令会引起处理器缓存回写到内存，在 P6 以后的处理器中，LOCK 信号一般不锁总线，而是锁缓存 </li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</li></ol><h5 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h5><p>MESI 协议，在 CPU 缓存中保存一个标记位，这个标记为有四种状态</p><ul><li>M(Modified) 修改缓存，当前 CPU 缓存已经被修改，表示已经和内存中的数据不一致了 </li><li>I(Invalid) 失效缓存，说明 CPU 的缓存已经不能使用了 </li><li>E(Exclusive)  独占缓存，当前 cpu 的缓存和内存中数据保持一直，而且其他处理器没有缓存该数据 </li><li>S(Shared)   共享缓存，数据和内存中数据一致，并且该数据存在多个 cpu 缓存中</li></ul><p>每个 Core 的 Cache 控制器不仅知道自己的读写操作，也监听其它 Cache 的读写操作，嗅探（snooping）协议 ，CPU 的读取会遵循几个原则：</p><ol><li>如果缓存的状态是 I，那么就从内存中读取，否则直接从缓存读取 </li><li>如果缓存处于 M 或者 E 的 CPU 嗅探到其他 CPU 有读的操作，就把自己的缓存写入到内存，并把自己的状态设置为 S </li><li>只有缓存状态是 M 或 E 的时候，CPU 才可以修改缓存中的数据，修改后，缓存状态变为 MC</li></ol><h5 id="执行优化"><a href="#执行优化" class="headerlink" title="执行优化"></a>执行优化</h5><ul><li><p>CPU：为了更充分利用处理器内内部的运算单元，处理器可能会对输入的代码进行的<strong>乱序执行优化</strong></p></li><li><p>编译器：<strong>指令重排来提升性能</strong></p></li></ul><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><h5 id="x86的cpu的内存屏障"><a href="#x86的cpu的内存屏障" class="headerlink" title="x86的cpu的内存屏障"></a>x86的cpu的内存屏障</h5><ul><li>写屏障（store barrier），相当于storestore barrier，强制所有在storestore内存屏障之前的所有执行，都要在该内存屏障之前执行，并发送缓存失效的信号。所有在storestore barrier指令之后的store指令，都必须在 storestore barrier屏障之前的指令执行完后再被执行。<strong>禁止了写屏障前后的指令进行重排序</strong>。</li><li>读屏障（load barrier），相当于loadload barrier，强制所有在load barrier读屏障之后的load指令，都在load barrier屏障之后执行。<strong>禁止对load barrier读屏障前后的load指令进行重排序</strong>，配合store barrier，使得所有store barrier之前发生的内存更新，对load barrier之后的load操作是可见的。</li><li>全屏障（Full Barrier），相当于storeload，是一个全能型的屏障。它同时具备前面两种屏障的效果。。强制了 所有在storeload barrier之前的store&#x2F;load指令，都在该屏障之前被执行，所有在该屏障之后的的store&#x2F;load指 令，都在该屏障之后被执行。<strong>禁止对storeload屏障前后的指令进行重排序。</strong></li></ul><h5 id="Java编译层面的内存屏障"><a href="#Java编译层面的内存屏障" class="headerlink" title="Java编译层面的内存屏障"></a>Java编译层面的内存屏障</h5><ul><li>LoadLoad Barriers：load1 ; LoadLoad; load2 , 确保load1数据的装载优先于load2及所有后续装载指令的装载。</li><li>StoreStore Barriers：store1; storestore;store2 , 确保store1数据对其他处理器可见优先于store2及所有后续存储指令的存储</li><li>LoadStore Barries：load1;loadstore;store2, 确保load1数据装载优先于store2以及后续的存储指令刷新到内存 </li><li>StoreLoad Barries：store1; storeload;load2, 确保store1数据对其他处理器变得可见， 优先于load2及所有后续装载指令的装载；这条内存屏障指令是一个全能型的屏障。</li></ul><h4 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h4><p>原子性、可见性、有序性</p><ul><li><p>缓存一致性就导致可见性问题</p></li><li><p>处理器的乱序执行会导致原子性问题、</p></li><li><p>指令重排会导致有序性问题</p></li></ul><h5 id="synchronized（原子性、可见性、有序性）"><a href="#synchronized（原子性、可见性、有序性）" class="headerlink" title="synchronized（原子性、可见性、有序性）"></a>synchronized（原子性、可见性、有序性）</h5><p>通过monitorenter和monitorexit保证原子性、可见性、有序性</p><h5 id="volatile（可见性、有序性）"><a href="#volatile（可见性、有序性）" class="headerlink" title="volatile（可见性、有序性）"></a>volatile（可见性、有序性）</h5><ul><li>防止指令重排序<ul><li>内存屏障<ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</li></ul></li></ul></li><li>保证多线程操作时变量的可见性<ul><li>volatile变量修饰的共享变量，在进行写操作的时候会多处一个lock前缀的汇编指令，会触发总线锁或者缓存锁，通过缓存一致性协议来解决可见性问题</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h5><ul><li>互斥</li><li>请求与保持</li><li>不剥夺</li><li>循环等待</li></ul><h5 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h5><ul><li>有序资源分配法</li><li>银行家算法</li></ul><h3 id="ThreadLocal为什么出现OOM？"><a href="#ThreadLocal为什么出现OOM？" class="headerlink" title="ThreadLocal为什么出现OOM？"></a>ThreadLocal为什么出现OOM？</h3><ul><li><p>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致内存泄漏</p></li><li><p>分配使用了ThreadLocal又不再调用get&#x2F;set&#x2F;remove方法，那么就会导致内存泄漏，因为这块内存一直存在</p></li></ul><p>当一个线程调用ThreadLocal的set方法设置变量时候，key为ThreadLocal的引用，value则为设置的值。如果当前线程一直存在而没有调用ThreadLocal的remove方法，由于线程的ThreadLocalMap里面的key是弱引用，则会在gc的时候被回收，但是对应的value是强引用，这时候ThreadLocalMap里面就会存在key为null但是value不为null的entry项，这样就会造成内存泄露。 ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><h3 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h3><p>useloadreadlock</p><p>assignstorewriteunlock</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多线程使用场景&quot;&gt;&lt;a href=&quot;#多线程使用场景&quot; class=&quot;headerlink&quot; title=&quot;多线程使用场景&quot;&gt;&lt;/a&gt;多线程使用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通过并行计算提高程序执行性能&lt;/li&gt;
&lt;li&gt;需要等待网络、I&amp;#x2F;O响应导致耗</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构设计</title>
    <link href="http://yoursite.com/2018/08/28/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/08/28/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2018-08-28T13:04:00.000Z</published>
    <updated>2024-07-31T03:16:37.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分布式系统的意义"><a href="#分布式系统的意义" class="headerlink" title="分布式系统的意义"></a>分布式系统的意义</h3><ul><li>升级单机处理能力的性价比越来越低</li><li>单机处理能力存在瓶颈</li><li>单机系统稳定性和可靠性很难达到</li></ul><h3 id="分布式常见概念"><a href="#分布式常见概念" class="headerlink" title="分布式常见概念"></a>分布式常见概念</h3><ul><li>集群</li><li>节点<ul><li>节点是指一个可以独立按照分布式协议完成一组逻辑的程序个体</li></ul></li><li>副本机制<ul><li>副本是指在分布式系统中为数据或服务提供的冗余</li></ul></li><li>中间件</li></ul><h3 id="架构的发展过程"><a href="#架构的发展过程" class="headerlink" title="架构的发展过程"></a>架构的发展过程</h3><ul><li>单应用架构</li><li>应用服务器和数据库服务器分离</li><li>应用服务器集群-应用服务器负载告警</li><li>数据库读写分离</li><li>引入缓存机制缓解数据库的压力</li><li>数据库的水平&#x2F;垂直拆分</li></ul><h3 id="分布式系统的难点"><a href="#分布式系统的难点" class="headerlink" title="分布式系统的难点"></a>分布式系统的难点</h3><ul><li>三态</li><li>分布式事务</li><li>负载均衡</li><li>一致性</li><li>故障的独立性</li></ul><h3 id="微服务的特征"><a href="#微服务的特征" class="headerlink" title="微服务的特征"></a>微服务的特征</h3><ol><li>通过服务实现组件化</li><li>按业务能力来划分服务和开发团队</li><li>去中心化</li><li>基础设施自动化（devops、自动化部署）</li></ol><h3 id="SOA和微服务的差别"><a href="#SOA和微服务的差别" class="headerlink" title="SOA和微服务的差别"></a>SOA和微服务的差别</h3><ol><li>微服务不再强调传统SOA里面比较重的ESB企业总线服务，同时SOA的思想进入到单个业务系统内部实现真正的组件化</li><li>SOA注重的是系统集成方面，微服务关注的是完全分离</li></ol><h3 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h3><ul><li>界限上下文（包名）</li><li>实体（entity）</li><li>值对象（valobj）</li><li>聚合根（aggregate）</li><li>领域服务（service）</li><li>资源库（repo）</li></ul><h3 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h3><ul><li>一致性问题<ul><li>强一致性</li><li>弱一致性</li><li>最终一致性</li></ul></li><li>CAP理论<ul><li>Consistency：一致性</li><li>Availability：可用性</li><li>Partition tolerance：分区容错性</li></ul></li><li>BASE理论<ul><li>Basically available：基本可用</li><li>Soft State：软状态</li><li>Eventually Consistent：数据最终一致性</li></ul></li></ul><h3 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h3><ol><li>避免单点故障<ol><li>负载均衡技术（failover&#x2F;选址&#x2F;硬件负载&#x2F;软件负载&#x2F;去中心化的软件负载（gossip（redis-cluster）））</li><li>热备（Linux HA）</li><li>多机房（同城灾备、异地灾备）</li></ol></li><li>应用的高可用性<ol><li>故障监控（系统监控（cpu、内存）&#x2F;链路监控&#x2F;日志监控）自动预警</li><li>应用的容错设计（服务降级、限流）、自我保护能力</li><li>数据量（数据分片、读写分离）</li></ol></li></ol><h3 id="分布式架构的可伸缩设计"><a href="#分布式架构的可伸缩设计" class="headerlink" title="分布式架构的可伸缩设计"></a>分布式架构的可伸缩设计</h3><ul><li>垂直伸缩（提升硬件能力）</li><li>水平伸缩（增加服务器）</li><li>加速静态内容访问速度的CDN</li></ul><h3 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h3><ul><li>百度 -&gt; DisConf</li><li>携程 -&gt; Appllo</li><li>阿里 -&gt; Nacos</li><li>Spring Cloud Config</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;分布式系统的意义&quot;&gt;&lt;a href=&quot;#分布式系统的意义&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的意义&quot;&gt;&lt;/a&gt;分布式系统的意义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;升级单机处理能力的性价比越来越低&lt;/li&gt;
&lt;li&gt;单机处理能力存在瓶颈&lt;/li</summary>
      
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式</title>
    <link href="http://yoursite.com/2018/08/26/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/26/%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2018-08-26T13:01:56.000Z</published>
    <updated>2024-07-31T03:16:37.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li><p>Consistency（一致性）</p><p>所有节点同一时间的数据完全一致</p></li><li><p>Availability（可用性）</p><p>每次请求都能获取到非错的响应</p></li><li><p>Partition Tolerance（分区容错）</p><p>当某节点或网络分区故障的时候，系统仍能够对外提供满足一致性和可用性的服务</p></li></ul><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><ul><li><p>Basically Consistency（基本可用）</p><p>系统发生不可预知的故障，运行损失部分可用性</p><ul><li>响应时间损失，延长响应时间</li><li>功能损失，降级页面</li></ul></li><li><p>Soft State（软状态）</p><p>数据副本在整个运行期间，允许某一时刻存在中间状态，但是最终数据的状态保持一致</p></li><li><p>Eventually Consistent（最终一致性）</p><p>在经过一定时间后，所有数据副本的状态都已经保持一致</p></li></ul><h3 id="一致性算法"><a href="#一致性算法" class="headerlink" title="一致性算法"></a>一致性算法</h3><ul><li>paxos<ul><li>基于消息传递且具有高度容错性的一致性算法</li></ul></li><li>raft</li></ul><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li>算法<ul><li>令牌桶<ul><li>按照固定的速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为0时则拒绝新的请求</li><li>限制的是平均流入速率，并允许一定程度突发流量</li></ul></li><li>漏桶<ul><li>按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新入的请求被拒绝</li><li>限制的是常量流出速率，从而平滑突发流入速率</li></ul></li><li>计数器<ul><li>滑动窗口算法</li></ul></li></ul></li><li>实现方案<ul><li>Nginx<ul><li><code>ngx_http_limit_conn_module</code>连接数限流模块</li><li><code>ngx_http_limit_req_module</code>请求限流模块（漏桶算法）</li></ul></li><li>Guava<ul><li><code>RateLimiter</code>令牌桶算法<ul><li><code>SmoothBursty</code>平滑突发限流</li><li><code>SmoothWarmingUp</code>平滑预热限流</li></ul></li></ul></li><li>Tomcat<ul><li><code>maxConnections</code>最大连接数</li><li><code>maxThreads</code>最大线程数</li><li><code>acceptCount</code>当tomgcat线程数达到最大时，接受排队的请求个数</li></ul></li><li>redis+lua</li><li>nginx+lua</li></ul></li></ul><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><ul><li><p>缓存</p></li><li><p>消息队列，推模式改成拉模式</p></li></ul><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><ul><li>当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时</li><li>HyStrix</li></ul><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><ul><li>当某个服务熔断之后，服务器将不再被调用，此时客户端返回一个缺省值</li></ul><h2 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h2><ul><li><p>session replication（session复制）</p></li><li><p>session sticky（固定同一台请求）</p></li><li><p>缓存集中式（Redis存session）</p></li></ul><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="数据结构类型"><a href="#数据结构类型" class="headerlink" title="数据结构类型"></a>数据结构类型</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul><li>sds（simple dynamic string）简单动态字符串</li><li>dict 维护key-value映射关系</li><li>quicklist</li><li>ziplist</li><li>skiplist</li><li>robj</li><li>intset</li></ul><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul><li>String<ul><li>set&#x2F;get&#x2F;decr&#x2F;incr</li></ul></li><li>Hash<ul><li>hset&#x2F;hget&#x2F;hexists</li></ul></li><li>List<ul><li>lpush&#x2F;rpush&#x2F;lpop&#x2F;rpop&#x2F;llen</li></ul></li><li>Set<ul><li>sadd&#x2F;srem&#x2F;scard&#x2F;sismember</li></ul></li><li>Sort Set<ul><li>zadd&#x2F;zcard&#x2F;zcount&#x2F;zrange&#x2F;zrem&#x2F;zscore</li></ul></li><li>transaction<ul><li>multi&#x2F;exec&#x2F;discard&#x2F;watch</li><li>Redis Cluster不支持</li></ul></li><li>pipeline<ul><li>JedisClusterConnection不支持</li><li>LettuceClusterConnection支持</li><li>openPipeline&#x2F;closePipeline</li><li>需注意批量命令大小，防止返回值超出内存</li><li>节省网络延迟的时间，非线程安全</li></ul></li></ul><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><ul><li>RDB<ul><li>快照，Redis支持将当前数据的快照存成一个数据文件的持久化机制</li></ul></li><li>AOF<ul><li>日志，append only file，追加写入的日志文件，可识别的纯文本，它的内容就是一个redis标准命令</li></ul></li></ul><h4 id="过期回收策略"><a href="#过期回收策略" class="headerlink" title="过期回收策略"></a>过期回收策略</h4><ul><li><code>noeviction</code>不回收</li><li><code>allkeys-lru</code>从所有键中删除最近最少使用的键</li><li><code>allkeys-random</code>从所有键中随机删除</li><li><code>volatile-lru</code>从设置了过期时间的键中删除最近最少使用的键</li><li><code>volatile-random</code>从设置了过期时间的键中随机删除</li><li><code>volatile-ttl</code>从设置了过期时间的键中选中存活时间最短的键删除</li></ul><h4 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h4><ul><li>Redis Cluster（官方）<ul><li>客户端直连Redis，免去了proxy代理的损耗</li><li>去中心化，最大可增加1000个节点，性能随节点增加而线性扩展</li><li>使用hash slot方式 将16384个hash slot 覆盖到所有节点上</li><li>简单易上手，管理方便，可自行增加或摘除节点，移动分槽等</li><li>一致性hash思想</li><li>不支持事务，不支持数据库切换，不支持mget，单个数据库</li></ul></li><li>codis（豌豆荚）<ul><li>多了一层代理</li><li>支持透明的扩&#x2F;缩容</li><li>具有图形化管理和监控工具，运维方便</li><li>数据根据key分布到1024个slot内</li></ul></li></ul><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>缓存雪崩<ul><li>数据未加载到缓存中，同一时间缓存全部失效，导致所有请求到查数据库</li><li>解决方法<ul><li>通过加锁控制缓存失效对数据库造成的压力</li><li>尽量让失效时间点均匀分布</li><li>二级缓存</li></ul></li></ul></li><li>缓存击穿<ul><li>类似缓存雪崩，缓存雪崩针对多个key，缓存击穿针对单个key过期，恰好在这个点有大并发的请求过滤，导致所有请求都到数据库</li><li>解决方法<ul><li>分布式锁</li></ul></li></ul></li><li>缓存穿透<ul><li>查询一个一定不存在的数据，导致每次都需要从数据库区查</li><li>解决方法<ul><li>对查询结果为空的情况也进行缓存，过期时间设置短一点</li><li>对一定不存在的key进行过滤</li></ul></li></ul></li><li>缓存预热<ul><li>系统上线前，将数据加载到缓存中</li><li>解决方法<ul><li>定时刷新缓存</li><li>单个缓存预热框架</li></ul></li></ul></li><li>缓存更新<ul><li>定时清理过期缓存，先判断缓存是否过期，过期再冲数据库查</li></ul></li><li>缓存降级<ul><li>对于不重要的数据，Redis故障，不查数据库，直接返回默认值</li></ul></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><ul><li>实现方案<ul><li>框架：redisson（内部lua脚本）</li><li>redlock算法<ul><li>尝试从N个相互独立的Redis实例获取锁，如果一个实例不可用，应该尽快尝试下一个</li><li>计算获取锁消耗时间，只有当这个时间小于锁的过期时间，并且从大多数（N&#x2F;2+1）实例上获取了锁，那么就认为锁获取成功了</li><li>如果获锁获取失败，会到每个实例上释放锁</li></ul></li><li>lua脚本实现</li></ul></li><li>优缺点<ul><li>性能高，可靠性没有zookeeper的高</li></ul></li></ul><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul><li>实现方案<ul><li>Curator</li></ul></li><li>优缺点<ul><li>性能没有Redis高，可靠性高</li></ul></li></ul><h2 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h2><h3 id="Redis-2"><a href="#Redis-2" class="headerlink" title="Redis"></a>Redis</h3><ul><li>轻量级，用于实时性较高的消息推送，不保证可靠性</li><li>没有相应的机制保证消息的消费，消费者消费失败，消息丢失</li><li>可靠发布&#x2F;队列监控&#x2F;流量控制都需要自行实现</li></ul><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><ul><li>支持持久化（内存&#x2F;文件&#x2F;数据库）</li><li>支持事务</li><li>支持协议（OpenWire&#x2F;STOMP&#x2F;REST&#x2F;XMPP&#x2F;AMQP）</li><li>可能出现消息丢失，不适合上千个队列的应用场景</li><li>社区不够活跃，5.x维护较少</li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul><li>性能好，具有持久化（内存&#x2F;文件）和消息确认机制，可靠性高</li><li>支持事务</li><li>支持协议（STOMP&#x2F;SMPP&#x2F;XMPP&#x2F;AMQP）</li><li>集群不支持动态扩展</li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul><li>高吞吐量，高可用性，严格保证消息顺序</li><li>支持持久化（磁盘文件）</li><li>支持事务</li><li>自已定义的一套协议</li><li>支持单机1万以上的持久化队列</li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>吞吐量高</li><li>基于pull模式来处理消息消费，主要用于日志收集和传输</li><li>不支持事务</li></ul><h3 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h3><ul><li>扩展性号，开发必须灵活，socket库的重新封装</li><li>不能持久化</li><li>不支持事务</li><li>不支持负载均衡</li></ul><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ul><li>消息队列使用场景<ul><li>异步处理，比如注册发送短信或邮件</li><li>应用解耦，比如用户下单，订单系统通知库存系统</li><li>流量削峰，比如控制流量暴增</li><li>消息通讯，比如点对点消息队列&#x2F;聊天室</li></ul></li><li>消息幂等<ul><li>全局ID，业务ID</li></ul></li><li>消息重发补偿<ul><li>指数退避策略，先隔x秒重发，2x秒重发，4x秒重发，以此类推</li></ul></li><li>消息堆积<ul><li>增加消费者的处理能力或减少发布频率；给消息设置年龄，超时就丢弃</li></ul></li><li>消息有序<ul><li>通过hash分配到一个队列里，每个队列只有一个消费者</li></ul></li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h3><ul><li>步骤<ul><li>准备阶段<ul><li>协调者询问所有的参与者是否可以提交事务</li><li>参与者执行询问发起为止的所有事务操作，并将Undo和Redo信息记录到事务日志中</li><li>各参与者响应协调者发起的询问，如果参与者阶段事务执行成功，返回同意，否则返回中止</li></ul></li><li>提交阶段<ul><li>协调者收到同意，则向参与者发起正式提交事务的请求，否则向参与者发起回滚事务的请求</li></ul></li></ul></li><li>实现案例<ul><li>TCC补偿模式<ul><li>Try 预留业务资源</li><li>Confirm 确认执行业务操作</li><li>Cancel 取消执行业务操作</li></ul></li><li>DTS</li><li>JTA</li></ul></li><li>缺点<ul><li>同步阻塞</li><li>数据不一致<ul><li>在阶段二中，如果协调者发送commit之后，网络故障，导致部分参与者收到了commit请求，这时收到了commit请求的参与者执行了事务提交，其他参与者无法进行提交</li></ul></li></ul></li></ul><h3 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h3><ul><li>步骤<ul><li>CanCommit<ul><li>协调者询问所有参与者是否可以执行事务</li></ul></li><li>PreCommit<ul><li>协调者向所有参与者发送preCommit请求，并进入Prepared阶段</li><li>参与者收到preCommit请求后，会执行事务，并将Undo和Redo信息记录到事务日志中</li><li>参与者反馈给协调者</li></ul></li><li>doCommit<ul><li>向所有参与者发送commit请求</li><li>参与者收到doCommit请求后，执行事务提交操作</li></ul></li></ul></li><li>缺点<ul><li>数据不一致<ul><li>在阶段三中，如果参与者收到commit消息后，网络故障，这种情况，参与者仍会提交事务</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分布式理论&quot;&gt;&lt;a href=&quot;#分布式理论&quot; class=&quot;headerlink&quot; title=&quot;分布式理论&quot;&gt;&lt;/a&gt;分布式理论&lt;/h2&gt;&lt;h3 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>jvm</title>
    <link href="http://yoursite.com/2018/08/23/jvm/"/>
    <id>http://yoursite.com/2018/08/23/jvm/</id>
    <published>2018-08-23T12:54:31.000Z</published>
    <updated>2024-07-31T03:16:37.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK版本</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><ul><li>swich可以支持字符串</li><li>创建泛型时类型自动推断</li></ul><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><ul><li>Lambda表达式</li><li>函数式接口<ul><li>FunctionalInterface<ul><li><code>Consumer</code>接收一个参数，无返回结果</li><li><code>Function</code>接收一个参数，返回一个结果</li><li><code>Predicate</code>接收一个参数，返回要给boolean结果</li><li><code>Supplier</code>不接收参数，返回一个结果</li></ul></li></ul></li><li>接口默认方法</li><li>方法引用<ul><li>类名::静态方法名</li><li>引用名或对象名::实例方法名</li><li>类名::实例方法名</li><li>类名::new（构造方法引用）</li></ul></li><li>重复注解</li><li>工具类<ul><li>Optional</li><li>Instant</li><li>LocalDate</li><li>LocalTime</li><li>Duration</li><li>Streams</li></ul></li></ul><h2 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>启动类加载器<ul><li>环境变量：sun.boot.class.path</li><li>加载lib下面的jar包；环境变量目录下的jar包和class文件</li><li>将.class文件放入到环境遍变量对应的目录下，即可以使用该类加载器加载</li></ul></li><li>扩展类加载器<ul><li>环境变量：java.ext.dirs</li><li>加载lib&#x2F;ext下的jar包，只能加载jar包，不能加载单独的class</li><li>将jar包放入环境变量对应的目录下，既可使用该类加载器加载</li></ul></li><li>系统类加载器<ul><li>环境变量：java.class.path</li><li>加载环境变量对应目录下的jar包和class文件</li><li>可设置java.system.class.loader改变系统类加载器</li></ul></li><li>自定义类加载器<ul><li>继承ClassLoader<ul><li>重写findClass方法<ul><li>调用defineClass方法</li></ul></li></ul></li></ul></li></ul><h3 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h3><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>当一个类加载器接收到类加载请求时，会先请求父类加载器去加载，如果所有的父类加载器都不能加载的时候，当前类加载器才会加载</p><ul><li><p>优点</p><ul><li>可以确保核心类库的安全性</li><li>可以确保Java核心类库的类不会被自定义类加载器加载</li><li>不同的类加载器可以为相同的类创建不同的命名空间</li></ul></li><li><p>规则</p><ul><li>父类加载器加载的类不能访问子类加载器加载的类</li><li>子类加载器加载的类可以访问父类加载器加载的类</li></ul></li><li><p>上下文类加载器</p><ul><li><p>打破了双亲委派模型规则</p></li><li><p>使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader();</span><br><span class="line">    <span class="comment">//具体业务逻辑实现</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩展</p><ul><li>SPI<ul><li>Java定制的一套规范，各大厂商各自实现各自的业务</li><li>使用了上下文类加载器</li><li>JDBC&#x2F;JNDI等</li></ul></li></ul></li></ul></li></ul><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><ul><li>首次主动使用<ul><li>创建一个实例</li><li>使用反射</li><li>调用类的静态方法或静态变量</li><li>为类的静态变量赋值</li><li>JVM启动时指定的类（包含main方法的类）</li><li>初始化一个子类，父类会被加载</li></ul></li></ul><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><ul><li>加载<ul><li>将class的二进制数据加载到内存中</li></ul></li><li>连接<ul><li>校验<ul><li>确保类的正确性<ul><li>类的文件结构检查</li><li>语义检查</li><li>字节码检查</li><li>二进制兼容性验证</li></ul></li></ul></li><li>准备<ul><li>为类的静态变量分配内存，并为其赋予初始值</li></ul></li><li>解析<ul><li>将类中的符号引用转换成直接引用<ul><li>符号引用<ul><li>在编译期间，Java类并不知道所引用的类的实际地址，因此只能使用符号代替</li></ul></li><li>直接引用<ul><li>直接指向目标的指针</li></ul></li></ul></li></ul></li></ul></li><li>初始化<ul><li>为类的静态变量赋予真正的初始值</li></ul></li><li>使用</li><li>卸载<ul><li>在JVM运行中，系统自带的类加载器加载的类无法卸载</li><li>自定义的类加载器加载的类可以卸载</li></ul></li></ul><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>记录每个线程下一步执行的JVM指令</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>局部变量表<ul><li>一组变量值存储空间，存放方法参数和方法内部定义的局部变量</li></ul></li><li>动态链接<ul><li>字节码中的方法调用指令以常量池中指向方法的符号引用为参数<ul><li>这些符号引用一部分在每次运行期间转化为直接引用，这部分称为动态连接</li><li>另外一部分在类加载阶段或第一次使用的时候转化为直接引用，这种称为静态解析</li></ul></li></ul></li><li>操作数栈<ul><li>方法执行过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈和出栈操作（后入先出栈）</li></ul></li><li>方法出口<ul><li>方法完成出口</li><li>异常完成出口</li></ul></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>默认初始大小和最大大小：物理内存的1&#x2F;4</p><p>默认情况下，空余堆小于40%，JVM会增大堆内存到最大堆大小，空余堆大于70%，JVM会减少堆内存到初始堆大小</p><ul><li>数组</li><li>对象<ul><li>内存布局<ul><li>对象头<ul><li>MarkWord，用与存储对象自身的运行时数据，如哈希码&#x2F;GC分带年龄&#x2F;锁状态标志&#x2F;线程持有的锁&#x2F;偏向线程ID&#x2F;偏向时间等</li><li>klass，类型指针，即指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li></ul></li><li>实例数据<ul><li>对象真正存储的有效信息，程序代码中定义的各种类型的字段内容</li></ul></li><li>对齐填充<ul><li>不是必然存在的，占位符的作用</li><li>由于HotSpot VM的自动内存管理系统要求对象的大小必须是8字节的整数倍，如果对象实例数据部分没有对齐时，需要通过对齐填充来补全</li></ul></li></ul></li><li>内存分配<ul><li>分配方法<ul><li>指针碰撞<ul><li>Serial&#x2F;ParNew等带Compact过程的收集器（标记-整理算法）</li><li>假设Java堆中内存是绝对规整的，所有用的内存都放在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离</li></ul></li><li>空闲列表<ul><li>CMS这种基于Mark-Sweep算法的收集器（标记-清除算法）</li><li>如果Java堆中内存不是规整的，已使用的内存和空闲的内存相互交错，那么虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li></ul></li></ul></li><li>分配类型<ul><li>栈上分配<ul><li>如果确定一个对象不会逃逸出方法之外，则可以让这个对象在栈上分配内存</li></ul></li><li>TLAB分配<ul><li>每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲</li></ul></li></ul></li><li>逃逸分析（当一个对象在方法中被定义后，它有可能被外部方法锁引用）<ul><li>方法逃逸<ul><li>比如作为调用参数传递到其他方法中</li></ul></li><li>线程逃逸<ul><li>有可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>JDK1.8使用元空间（MetaSpace）代替</p><p>默认初始大小：物理内存的1&#x2F;64</p><p>默认最大大小：物理内存的1&#x2F;4</p><ul><li>内中方法</li><li>静态变量</li><li>final常量</li><li>类信息</li></ul><h3 id="本地方法区"><a href="#本地方法区" class="headerlink" title="本地方法区"></a>本地方法区</h3><p>存放native方法</p><p>执行引擎</p><h3 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h3><h4 id="收集算法"><a href="#收集算法" class="headerlink" title="收集算法"></a>收集算法</h4><h5 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h5><ul><li>引用计数法<ul><li>给对象添加一个引用计数器，每当有一个地方引用该对象时，计数值+1，当该对象引用失效时，计数值-1，计数器值为0的对象则可以进行回收</li><li>无法检测出循环引用</li></ul></li><li>可达性分析算法<ul><li>从GCRoots根节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，则证明此对象不可用<ul><li>GCRoots<ul><li>虚拟机栈中引用的对象</li><li>方法区静态属性引用的对象</li><li>方法区常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul></li></ul></li></ul></li></ul><h5 id="收集算法-1"><a href="#收集算法-1" class="headerlink" title="收集算法"></a>收集算法</h5><ul><li>复制算法<ul><li>将现有空间分为两块，每次只使用其中一块，垃圾回收时将正在使用的内存中存活的对象复制到未被使用的内存块中，之后清除正在使用的内存块中所有对象，然后交换两个内存块的角色</li><li>缺点<ul><li>浪费一半内存</li><li>如果所有对象都存活，那么复制效率低下</li></ul></li></ul></li><li>标记-清理算法<ul><li>过程<ul><li>标记阶段，遍历GC Roots，标记存活的对象</li><li>清除阶段，遍历堆中所有对象，清除未被标记的对象</li></ul></li><li>缺点<ul><li>效率低（递归与全堆对象遍历）</li><li>造成大量的空间碎片</li></ul></li></ul></li><li>标记-整理算法<ul><li>标记阶段，遍历GC Roots，标记存活的对象</li><li>整理阶段，移动所有存活对象，按照内存地址依次排序，然后将末端内存地址以后的内存全部回收</li></ul></li></ul><h4 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h4><ul><li>新生代（stop the world）<ul><li>Serial（串行收集器）采用复制算法</li><li>Parallel Scavenge（并行收集器）采用复制算法</li><li>ParNew（并行收集器）采用复制算法</li></ul></li><li>老年代<ul><li>Serial Old（串行收集器）标记-整理算法</li><li>Parallel Old（并行收集器）标记-整理算法</li><li>CMS（并发收集器）标记-清理算法<ul><li>标记-清除过程<ul><li>初始标记（Stop The World）<ul><li>标记被年轻代中存活对象引用的直接对象</li><li>标记老年代中所有GC Roots能直接关联到的对象</li></ul></li><li>并发标记<ul><li>从“初始标记”阶段标记的对象开始标记所有存活的对象</li></ul></li><li>重新标记（Stop The World）<ul><li>进行可达性分析，标记GCRoots能直接关联到的对象</li><li>可设置<code>-XX:CMSScavengeBeforeRemark</code>在标记前触发新生代GC</li></ul></li><li>并发清除<ul><li>清除没有标记的对象，并且回收空间</li></ul></li></ul></li><li>压缩策略（满足任意条件都会压缩）<ul><li>UseCMSCompactAtFullCollection为true和CMSFullGCsBeforeCompaction上一次GC执行过后，还需要多少次full gc才会做压缩，默认0。</li><li>用户调用System.gc()，而且DisableExplicitGC没有开启</li><li>新生代预计老年代没有足够空间来容纳下次新生代晋升的对象</li></ul></li><li>优点<ul><li>并发收集，低停顿</li></ul></li><li>缺点<ul><li>内存碎片；对CPU资源非常敏感；需要更大的堆；无法处理浮动垃圾</li></ul></li><li>常见问题<ul><li>promotion failed<ul><li>在Minor GC时，Survivor Space放不下对象只能进入老年代，而此时老年代也放不下造成的，多数是老年代没有足够的空闲空间，但是由于碎片多，没有连续的空闲空间</li><li>解决方法<ul><li>调大新生代或Survivor空间或者让CMS进行一定次数的Full GC的时候进行一次标记整理算法（-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction&#x3D;5）</li></ul></li></ul></li><li>concurrent mode failure<ul><li>在执行CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足，这时CMS还没有机会回收老年代产生的</li><li>在Minor GC的时候，Survivor放不下，需要放入老年代，而老年代也放不下产生的</li><li>如果对象分配率高于CMS回收的效率，将导致在CMS完成之前老年代就被填满</li><li>解决方法<ul><li>调低触发CMS GC执行的阈值</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>整堆<ul><li>G1（并发收集器）标记-整理算法<ul><li>结构<ul><li>将堆分成多个大小相同的Region，默认2048个，在1-32M之间</li><li>每个Region的大小只能是2的幂次方，可通过-XX:G1HeapRegionSize指定大小</li><li>逻辑上分成Eden、Survivor、Old、Humongous（巨型）、空闲，大小不固定，根据每次GC的信息做出调整</li><li>新建对象超过Region大小的一半时，直接在一个Region或多个连续的Region中分配，并标记为Humongous</li><li>H-Object在Global Concurrent Marking阶段cleanup或Full GC阶段回收</li></ul></li><li>优点<ul><li>并行与并发</li><li>停顿时间可控，可配置预期停顿时间来控制GC时间，避免雪崩</li></ul></li><li>收集算法<ul><li>新生代采用复制算法</li><li>老年代采用标记-整理算法</li></ul></li><li>Young GC（STW）当所有Eden Region被耗尽无法申请内存时，就会触发一次Young GC</li><li>Mixed GC（回收一部分老年代）<ul><li>标记整理过程<ul><li>初始标记（STW）<ul><li>共用了Young GC的暂停，标记从GC Roots开始直接可达的对象</li></ul></li><li>扫描根引用区<ul><li>初始标记后，Eden区被清空，存活对象被移入Survivor区，在这阶段，将扫描由Survivor区直接可达的老年代区域，并标记存活对象</li><li>并发执行，不能和Young GC同时执行，如果此时由Young GC，则Young GC会暂停</li></ul></li><li>并发标记<ul><li>从GC Root开始对堆中的对象标记，标记线程与应用线程并行执行，并且收集各个Region的存活对象信息</li><li>可能被Young GC中断，如果发现Region中的所有对象都是垃圾，那么这个Region会被立即回收</li></ul></li><li>重新标记（STW）<ul><li>标记在“并发标记”阶段产生的新垃圾，使用SATB算法</li></ul></li><li>清除（STW）<ul><li>对存活的对象和完全空的区域进行统计（STW）</li><li>刷新Remembered Sets（STW）</li><li>重置空的区域，放到Free List</li></ul></li><li>复制（STW）<ul><li>将存活对象复制到未使用的区域中</li></ul></li></ul></li><li>使用-XX:InitiatingHeapOccupancyPercent设置Mixed GC的阈值，当老年代大小占整堆大小百分比达到阈值时，会触发一次Mixed GC</li></ul></li><li>Full GC<ul><li>如果对象内存分配速度过快，Mixed GC来不及回收，导致老年代被填满，就会触发一次Full GC<ul><li>解决方法：增加堆大小</li></ul></li><li>在进行GC的时候没有足够的内存供存活对象或晋升对象使用，就会触发Full GC<ul><li>解决方法<ul><li>增加-XX:G1ReservePercent选项的值，为“目标空间”增加预留内存地址</li><li>通过减少-XX:InitiatingHeadOccupancyPercent提前启动标记周期</li><li>增加-XX:ConcGCThreads选项的值来增加并行标记线程的数目</li></ul></li></ul></li><li>巨型对象找不到合适的空间进行分配时，就会触发Full GC<ul><li>解决方法<ul><li>增加堆大小</li><li>使用-XX:G1HeapRegionSize修改Region的大小，使巨型对象不再是巨型对象</li></ul></li></ul></li><li>G1的Full GC算法是单线程执行Serial Old过程，会导致长时间的暂停时间，需要进行不断的调优，尽可能的避免Full GC</li></ul></li></ul></li></ul></li></ul><h4 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h4><ul><li>吞吐量<ul><li>应用系统的生命周期内，应用程序所花费的时间和系统总运行时间的比值</li><li>系统总运行时间 &#x3D; 应用程序耗时 + GC耗时</li><li>如果系统运行了100分钟，GC耗时1分钟，则系统吞吐量 &#x3D; 99%</li></ul></li><li>垃圾回收器负载<ul><li>GC耗时 &#x2F; 系统总运行时间</li></ul></li><li>停顿时间<ul><li>垃圾回收器运行时，应用程序的暂停时间</li></ul></li><li>垃圾回收频率<ul><li>垃圾回收器多长时间运行一次</li><li>一般而言，频率越低越好，通常增大堆空间可以有效降低垃圾回收发送的频率，但是会增加回收时产生的停顿时间</li></ul></li><li>反应时间<ul><li>当一个对象成为来及后，多长时间内，它所占用的内存空间会被释放掉</li></ul></li></ul><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li>过早提升<ul><li>在Minor GC过程中，Survivor UnUsed可能不足以容纳Eden和Survivor中存活的对象，那么多余的对象将被移到老年代，称为过早提升</li><li>Survivor空间太小，容纳不下全部运行时短生命周期的对象<ul><li>解决方法：调大Survivor空间</li></ul></li><li>对象太大，Survivor和Eden没有足够大的空间来存放这些对象</li></ul></li><li>提升失败<ul><li>过早提升会导致老年代中短期存活对象的增长，如果老年代满了，Minor GC后会进行Full GC，将导致遍历整个堆，称为提升失败</li><li>造成原因<ul><li>老年代空闲空间不够<ul><li>解决方法：将CMS触发的阈值调低</li></ul></li><li>老年代空闲空间多，但是碎片太多，没有连续的空闲空间存放对象<ul><li>解决方法：CMS需要进行空间整理压缩</li></ul></li></ul></li></ul></li></ul><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><h4 id="C1-编译器（Client-Compiler）"><a href="#C1-编译器（Client-Compiler）" class="headerlink" title="C1 编译器（Client Compiler）"></a>C1 编译器（Client Compiler）</h4><ul><li>方法内联</li><li>去虚拟化</li><li>冗余消除</li></ul><h4 id="C2-编译器（Server-Compiler）"><a href="#C2-编译器（Server-Compiler）" class="headerlink" title="C2 编译器（Server Compiler）"></a>C2 编译器（Server Compiler）</h4><ul><li>标量替换</li><li>栈上分配</li><li>同步消除</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul><li>偏向锁<ul><li>只有一个线程在访问，不存在多线程竞争的情况</li></ul></li><li>轻量级锁<ul><li>线程交替执行同步块的情况下使用轻量级锁</li></ul></li><li>重量级锁<ul><li>如果存在同一时间访问同一锁的情况，轻量级锁会膨胀为重量级锁</li><li>监视器锁，依赖底层操作系统Mutex Lock所实现的锁，用户态转换到核心态需要很长时间</li></ul></li><li>自旋锁<ul><li>让线程执行无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环；默认自旋10次</li><li>自适应自旋锁<ul><li>自旋锁的优化，自旋时间不固定，由前一次在同一锁上的自旋时间及锁的拥有者的状态来决定</li></ul></li></ul></li></ul><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>虚拟机探测到一串零碎的操作都对同一对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部</p><h3 id="锁削除"><a href="#锁削除" class="headerlink" title="锁削除"></a>锁削除</h3><p>虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行削除</p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul><li>堆参数<ul><li>-Xms&#96;设置初始堆大小</li><li><code>-Xmx</code>设置最大堆大小</li><li><code>-Xmn</code>设置年轻代大小</li><li><code>-Xss</code>设置线程堆栈大小<ul><li>Xss越大，每个线程的大小就越大，占用的内存就越多，能容纳的线程就越少</li><li>Xss越小，则递归的深度越小，容易出现栈溢出（StackOverflowError），减少局部变量的声明，可以节省栈帧大小，增加调用深度</li></ul></li><li><code>-XX:NewRatio=n</code>设置新生代和老年代比例<ul><li>如果n&#x3D;8，则新生代和老年代的比例1：8，新生代占比1&#x2F;9</li></ul></li><li><code>-XX:SurvivorRatio=n</code>设置新生代Eden和Survivor的比例<ul><li>新生代中有2个survivor区域，如果n&#x3D;8，则eden和survivor的比例8：2，一个survivor占新生代1&#x2F;10</li></ul></li><li><code>-XX:PermSize=n</code>设置方法区（持久代）初始大小</li><li><code>-XX:MaxPermSize=n</code>设置方法区（持久代）最大大小</li><li><code>-XX:TargetSurvivorRatio=n</code>目标存活率<ul><li>如果n&#x3D;50%，在survivor空间中相同年龄所有对象大小的总和大于50%时，年龄大于等于该年龄的对象就可以直接进入老年代</li></ul></li><li><code>-XX:MaxTenuringThreshold=n</code>设置对象在新生代中survivor存活的年龄<ul><li>默认15，如果n&#x3D;13，则新生代gc13次之后，对象会从新生代survivor中晋升到老年代</li></ul></li></ul></li><li>收集器参数<ul><li><code>-XX:+UseSerialGC</code>（Serial + Serial Old）</li><li><code>-XX:+UseParallelGC</code>（Parallel Scavenge + Parallel Old）</li><li><code>-XX:+UseParNewGC</code>（ParNew + Serial Old）</li><li><code>-XX:+UseParallelOldGC（JDK1.5后失效）</code>（Parallel Scavenge + Parallel Old）</li><li><code>-XX:+UseConcMarkSweepGC</code>（ParNew + CMS）</li></ul></li><li>并行参数<ul><li><code>-XX:ParallelGCThreads=n</code>设置并行收集器并行收集线程数</li><li><code>-XX:MaxGCPauseMillis=n</code>设置每次年轻的垃圾回收最长时间（最大暂停时间）</li><li><code>-XX:GCTimeRatio=n</code>设置垃圾回收时间占程序运行时间的百分比</li></ul></li><li>并发参数<ul><li><code>-XX:+CMSIncrementalMode</code>设置为增量模式，适用于单CPU环境</li><li><code>-XX:ParallelGCThreads=n</code>设置并发收集器年轻代收集为并行收集器时，并行收集线程数</li></ul></li><li>统计参数设置<ul><li><code>-XX:+PrintGC</code>打印GC信息</li><li><code>-XX:+PrintGCDetails</code>打印GC信息</li><li><code>-XX:+PrintGCTimeStamps</code>打印GC信息</li><li><code>-XX:+PrintHeapAtGC</code>打印GC前后的详细堆栈信息</li><li><code>-Xloggc:filename</code>将日志信息记录到文件中</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDK版本&quot;&gt;&lt;a href=&quot;#JDK版本&quot; class=&quot;headerlink&quot; title=&quot;JDK版本&quot;&gt;&lt;/a&gt;JDK版本&lt;/h2&gt;&lt;h3 id=&quot;JDK1-7&quot;&gt;&lt;a href=&quot;#JDK1-7&quot; class=&quot;headerlink&quot; title=&quot;J</summary>
      
    
    
    
    <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
    <category term="类加载器" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
    <category term="垃圾回收" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="http://yoursite.com/2018/08/20/dubbo/"/>
    <id>http://yoursite.com/2018/08/20/dubbo/</id>
    <published>2018-08-20T15:25:52.000Z</published>
    <updated>2024-07-31T08:06:39.283Z</updated>
    
    <content type="html"><![CDATA[<p>高性能RPC框架，主要用于服务治理。包括功能：</p><ul><li>负载均衡（默认加权随机）</li><li>集群容错（默认failover）</li><li>服务降级</li><li>监控（Monitor）<ul><li>提供者和消费者定时每分钟发送一次统计数据到监控中心</li></ul></li><li>服务注册与发现<br>特点：连通性、健壮性、伸缩性<span id="more"></span></li></ul><h3 id="启动检查机制"><a href="#启动检查机制" class="headerlink" title="启动检查机制"></a>启动检查机制</h3><ul><li>关闭某个服务的启动时检查<br>xml：<code>&lt;dubbo:reference interface=&quot;com.lee9213.service.IHelloService&quot; check=&quot;false&quot;&gt;</code><br>properties：<code>dubbo.reference.com.lee9213.service.IHelloService.check=false </code><br>-D参数：<code>java -Ddubbo.reference.com.lee9213.service.IHelloService.check=false </code></li><li>关闭所有服务的启动时检查<br>xml：<code>&lt;dubbo:consumer check=&quot;false&quot;/&gt;</code><br>properties：<code>dubbo.consumer.check=false </code><br>-D参数：<code>java -Ddubbo.consumer.check=false </code></li><li>关闭注册中心启动时检查<br>xml：<code>&lt;dubbo:registry check=&quot;false&quot;/&gt;</code><br>properties：<code>dubbo.registry.check=false </code><br>-D参数：<code>java -Ddubbo.registry.check=false </code></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>RandomLoadBalance（加权随机）默认<ul><li>计算出总权重</li><li>根据总权重获取权重随机数，遍历IP，进行权重递减，当权重小于0时，取下标</li></ul></li><li>LeastActiveLoadBalance（加权最小活跃）<ul><li>取出最小活跃数相同的机器，如果权重相同，则随机选取</li><li>取出最小活跃数相同的机器，如果权重不同，按照加权随机算法选取</li></ul></li><li>RoundRobinLoadBalance（加权轮询）</li><li>ConsistentHashLoadBalance（一致性hash）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置key：random、roundrobin、leastactive、consistenthash --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 服务端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;random&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 客户端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 服务端方法级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;leastactive&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 客户端方法级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;consistenthash&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h3><ul><li>容错机制：某种系统控制在一定范围内的一种允许或包容犯错情况的发生</li><li>容错策略<ul><li>failsafe：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>failover：<strong>默认策略</strong>，失败自动切换，当出现失败，重试其他服务器。通常用于读操作，但重试会带来更长延迟，可通过<code>retries=&quot;2&quot;</code>来设置重试次数，默认2次（不含第一次）。</li><li>failfast：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>failback：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>forking：并行调用多个服务器，只要一个成功即返回。通常用于实时性较高的读操作，但需要浪费更多服务资源。可通过<code>forks=&quot;2&quot;</code>来设置最大并行数。</li><li>broadcast：广播所有提供者，逐个调用，任意一台报错即报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul></li><li>配置方式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置cluster属性，指定容错策略，默认failover --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.lee9213.service.IHelloService&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><ul><li>人工降级和自动降级</li><li>功能区分：读服务降级和写服务降级</li><li>故障降级（设置默认值&#x2F;采用兜底数据）</li><li>dubbo降级方式：Mock方式</li><li>集群容错策略为failsafe&#x2F;failback时，<strong>不能使用降级</strong><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个mock属性，对应的值是属性interface对应接口的实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.lee9213.service.IHelloService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">mock</span>=<span class="string">&quot;com.lee9213.service.mock.HelloServiceMock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Registry（注册中心）"><a href="#Registry（注册中心）" class="headerlink" title="Registry（注册中心）"></a>Registry（注册中心）</h3><p>Dubbo支持同一服务向多注册中心同时注册或不同服务分别注册到不同的注册中心。</p><ul><li><p>DubboRegistry（Netty实现）</p></li><li><p>ZookeeperRegistry（zookeeper实现）</p></li><li><p>RedisRegistry（Redis实现）</p></li><li><p>MulticastRegistry（广播，去中心化，不需要安装注册中心）<br>组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段: 224.0.0.0 - 239.255.255.255</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多注册中心配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;zk1Registry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.0.1:2181&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;zk2Registry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://192.168.0.2:2181&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 向多个注册中心注册 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;zk1Registry,zk2Registry&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 不同服务注册到不同注册中心 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 向zk1Registry注册中心注册 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;zk1Registry&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 向zk2Registry注册中心注册 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;zk2Registry&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Container（容器）"><a href="#Container（容器）" class="headerlink" title="Container（容器）"></a>Container（容器）</h3><ul><li>SpringContainer（默认）</li><li>JettyContainer（启动一个内嵌Jetty）</li><li>Log4jContainer（自动配置log4j的配置）</li><li>LogbackContainer</li></ul><h3 id="Protocol（协议）"><a href="#Protocol（协议）" class="headerlink" title="Protocol（协议）"></a>Protocol（协议）</h3><p>Dubbo允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议</p><ul><li><p>HttpProtocol（基于HTTP表单的远程调用协议，采用Spring的HttpInvoker实现）</p><ul><li>连接个数：多连接</li><li>连接方式：短连接</li><li>传输协议：HTTP</li><li>传输方式：同步传输</li><li>序列化：表单序列化</li><li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。</li><li>适用场景：需同时给应用程序和浏览器 JS 使用的服务。</li></ul></li><li><p>RmiProtocol（采用JDK标准的<code>java.rmi.*</code>实现，采用阻塞式短连接和JDK标准序列化方式。）</p><ul><li>连接个数：多连接</li><li>连接方式：短连接</li><li>传输协议：TCP</li><li>传输方式：同步传输</li><li>序列化：Java 标准二进制序列化</li><li>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。</li><li>适用场景：常规远程服务方法调用，与原生RMI服务互操作</li><li>dubbo 配置中的超时时间对RMI无效，需使用java启动参数设置：<code>-Dsun.rmi.transport.tcp.responseTimeout=3000</code></li></ul></li><li><p>HessianProtocol（底层采用Http通讯，采用Servlet暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现）</p><ul><li>连接个数：多连接</li><li>连接方式：短连接</li><li>传输协议：HTTP</li><li>传输方式：同步传输</li><li>序列化：Hessian二进制序列化</li><li>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</li><li>适用场景：页面传输，文件传输，或与原生hessian服务互操作</li></ul></li><li><p>ThriftProtocol（Netty实现）</p></li><li><p>DubboProtocol（Netty实现，采用NIO复用单一长连接）</p><ul><li>连接个数：单连接</li><li>连接方式：长连接</li><li>传输协议：TCP</li><li>传输方式：NIO 异步传输</li><li>序列化：Hessian 二进制序列化</li><li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</li><li>适用场景：常规远程服务方法调用</li></ul></li><li><p>InjvmProtocol</p></li><li><p>WebServiceProtocol（基于WebService的远程调用协议，基于Apache CXF的<code>frontend-simple</code> 和 <code>transports-http</code>实现)</p><ul><li>连接个数：多连接</li><li>连接方式：短连接</li><li>传输协议：HTTP</li><li>传输方式：同步传输</li><li>序列化：SOAP 文本序列化</li><li>适用场景：系统集成，跨语言调用</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;...&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;...&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;rmi&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用不同协议暴露同一服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;...&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo,rmi&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="多版本支持"><a href="#多版本支持" class="headerlink" title="多版本支持"></a>多版本支持</h3><p>在dubbo配置文件中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.lee9213.service.IHelloService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.lee9213.service.IHelloService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lee9213.service.impl.HelloServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在zookeeper会生成不同url的两个节点</p><h3 id="主机绑定"><a href="#主机绑定" class="headerlink" title="主机绑定"></a>主机绑定</h3><p>发布服务时会生成一个dubbo:&#x2F;&#x2F;ip:prot的协议地址</p><ol><li><p>从<code>&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; host=&quot;192.168.0.18&quot;/&gt;</code>配置中获取<code>host</code>的属性值</p></li><li><p>如果步骤1中获取到的地址无效，则从<code>InetAddress.getLocalHost().getHostAddress()</code>中获取</p></li><li><p>如果步骤2中获取到的地址无效，则通过连接zookeeper，然后获取连接zookeeper的客户端的本地地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接zookeeper</span></span><br><span class="line"><span class="type">SocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(registryURL.getHost(),registryURL.getPort());</span><br><span class="line">socket.connect(addr, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 获取连接zookeeper的客户端的本地地址</span></span><br><span class="line">host = socket.getLocalAddress().getHostAddress();</span><br></pre></td></tr></table></figure></li><li><p>如果步骤3中未获取到地址，则从<code>NetUtils.getLocalHost()</code>获取地址。</p></li></ol><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><ul><li>XML配置<br>以timeout为例，显示了配置的查找顺序，其他retries、loadbalance等类似。<ul><li>方法级优先，接口级次之，全局配置再次之。</li><li>如果级别一样，则消费者优先，提供者次之。<br>其中，服务提供方配置，通过URL经由注册中心传递给消费方。建议由服务提供方设置超时。</li></ul></li><li>属性配置参数优先级<ul><li>JVM启动参数优先，比如 <code>-Ddubbo.protocol.port=20880</code>，</li><li>XML次之，比如 <code>&lt;dubbo:protoocol port=&quot;20880&quot;/&gt;</code></li><li>Properties最后，相当于缺省值。比如 <code>dubbo.protocol.port=20880</code></li></ul></li></ul><h3 id="Dubbo-SPI和Java-SPI区别"><a href="#Dubbo-SPI和Java-SPI区别" class="headerlink" title="Dubbo SPI和Java SPI区别"></a>Dubbo SPI和Java SPI区别</h3><h4 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h4><p>service provider interface，JDK内置的一种服务提供发现机制，动态替换发现的机制。</p><ul><li>规范<ol><li>需在META-INF&#x2F;services下建立一个文件，文件的规范：<ol><li>文件名必须是扩展的接口的全路径名称</li><li>文件内部描述的是该扩展接口的所有实现类</li><li>文件的编码格式必须是UTF-8</li></ol></li><li>通过java.util.ServiceLoader来加载</li></ol></li><li>缺点<ol><li>JDK标准的SPI会一次性加载实例化扩展点的所有实现，如果有的扩展点实现初始化很耗时或者有些实现类并没有用到，这样就会很耗费资源</li><li>如果扩展点加载失败，会导致调用方报错，而且这个错误很难定位到某个原因</li></ol></li></ul><h4 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h4><ul><li>规范<ol><li>需建立要给配置文件，目录为：META-INF&#x2F;dubbo、META-INF&#x2F;dubbo&#x2F;internal、META-INF&#x2F;services</li><li>文件名必须是扩展的接口的全路径名称，内容是key-value<ul><li>key：别名</li><li>value：扩展接口的实现类</li></ul></li></ol></li><li>知识点<ul><li>@Adaptive：自适应扩展点<ul><li>类级别：直接加载当前自定义的自适应扩展点</li><li>方法级别：动态生成一个自适应扩展点，比如：Protocol$Adaptvie、Container$Adaptive</li><li>自动包装扩展点的 Wrapper 类。<code>ExtensionLoader</code> 在加载扩展点时，如果加载到的扩展点有拷贝构造函数，则判定为扩展点 Wrapper 类。Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。扩展点的 Wrapper 类可以有多个。（AOP实现）</li><li>加载扩展点时，自动注入依赖的扩展点。加载扩展点时，扩展点实现类的成员如果为其它扩展点类型，<code>ExtensionLoader</code> 在会自动注入依赖的扩展点。<code>ExtensionLoader</code> 通过扫描扩展点实现类的所有 setter 方法来判定其成员。即 <code>ExtensionLoader</code> 会执行扩展点的拼装操作。（IOC实现）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认扩展点，此处代表获取Container的SPI注解的value所指定的扩展点SpringContainer</span></span><br><span class="line">ExtensionLoader.getExtensionLoader(Container.class).getDefaultExtension();</span><br><span class="line"><span class="comment">// 获取自适应扩展点，此处代表获取Container的自适应扩展点Container$Adaptive</span></span><br><span class="line">ExtensionLoader.getExtensionLoader(Container.class).getAdaptiveExtension()</span><br></pre></td></tr></table></figure>@Activate：自动激活</li></ul></li></ul></li></ul><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="Dubbo中Spring-XML扩展"><a href="#Dubbo中Spring-XML扩展" class="headerlink" title="Dubbo中Spring XML扩展"></a>Dubbo中Spring XML扩展</h4><p>Dubbo是基于spring配置来实现服务的发布的，</p><ol><li>新建xsd文件，配置标签内容，在META-INF&#x2F;spring.schemas文件中声明xsd路径</li><li>实现BeanDefinitionParser接口</li><li>继承NamespaceHandlerSupport ，重写init方法，调用registerBeanDefinitionParser注册标签解析器</li><li>在META-INF&#x2F;spring.handlers文件中声明步骤2中实现类</li></ol><h4 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个ExtensionLoader</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="title function_">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个自适应扩展点</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">// 判断如果不存在自适应扩展点，则调用</span></span><br><span class="line">    createAdaptiveExtension()；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自适应扩展点</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自适应扩展点进行依赖注入，为适配器类的setter方法注入其他扩展点（IOC实现）</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个自适应适配器类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 加载所有路径下的扩展点的类</span></span><br><span class="line">    <span class="comment">// 路径包括：META-INF/dubbo、META-INF/dubbo/internal、META-INF/services</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="comment">// 如果不存在，动态生成适配器代码，以及动态编译，返回一个动态创建的自适应适配器的类</span></span><br><span class="line">    <span class="comment">// Compiler可以动态扩展，自带实现有AdaptiveCompiler、JdkCompiler、JavassistCompiler</span></span><br><span class="line">    <span class="comment">// 默认使用AdaptiveCompiler，AdaptiveCompiler中默认的是JavassistCompiler</span></span><br><span class="line">    <span class="comment">// 最终使用JavassistCompiler编译</span></span><br><span class="line">    <span class="comment">// 返回一个自适应适配器类,类名类似Protocol$Adaptive、Cluster$Adaptive</span></span><br><span class="line">    <span class="comment">// Protocol$Adaptive的作用</span></span><br><span class="line">    <span class="comment">// 1. 从URL或扩展接口获取扩展接口实现类的名称</span></span><br><span class="line">    <span class="comment">// 2. 根据名称，获取最终需要的扩展点实现类</span></span><br><span class="line">    <span class="comment">// 适配器类的目的是在运行期获取扩展的真正实现来调用，解耦接口和实现</span></span><br><span class="line">    createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个扩展点的实现类</span></span><br><span class="line"><span class="comment">// 如果一个扩展点的实现类的构造函数包含了这个扩展点的接口，则这个实现类是对这个扩展点的包装，比如ProtocolFilterWrapper和ProtocolListenerWrapper对Protocol进行了包装</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="RpcContext"><a href="#RpcContext" class="headerlink" title="RpcContext"></a>RpcContext</h4><ol><li>获取上下文信息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：每发起RPC调用，上下文状态会变化</span></span><br><span class="line"><span class="comment">// 获取最后一次调用的提供方IP地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">serverIP</span> <span class="operator">=</span> RpcContext.getContext().getRemoteHost();</span><br><span class="line"><span class="comment">// 获取当前服务配置信息，所有配置信息都将转换为URL的参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">application</span> <span class="operator">=</span> RpcContext.getContext().getUrl().getParameter(<span class="string">&quot;application&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>隐式传参<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：path、group、version、dubbo、token、timeout几个key是保留字段，请使用其它值</span></span><br><span class="line"><span class="comment">// 消费者端隐式传参，后面的远程调用都会隐式将这些参数发送到服务端，用于框架集成，不建议常规业务使用</span></span><br><span class="line">RpcContext.getContext().setAttachment(<span class="string">&quot;index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">xxxService.xxx(); <span class="comment">// 远程调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供者端，获取客户端隐式传入的参数，用于框架集成，不建议常规业务使用</span></span><br><span class="line">RpcContext.getContext().getAttachment(<span class="string">&quot;index&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>异步调用（基于NIO的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">async：开启异步执行，默认false</span></span><br><span class="line"><span class="comment">sent：true（等待消息发出，消息发送失败将抛出异常）/false（不等待消息发出，将消息放入IO队列）</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">async</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sent</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此调用会立即返回null</span></span><br><span class="line">fooService.findFoo(fooId);</span><br><span class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></span><br><span class="line">Future&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 此调用会立即返回null</span></span><br><span class="line">barService.findBar(barId);</span><br><span class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></span><br><span class="line">Future&lt;Bar&gt; barFuture = RpcContext.getContext().getFuture(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//此时findFoo和findBar的请求同时在执行，客户端不需要启动多线程来支持并行，而是借助NIO的非阻塞完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果foo已返回，直接拿到返回值，否则线程wait住，等待foo返回后，线程会被notify唤醒</span></span><br><span class="line"><span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> fooFuture.get(); </span><br><span class="line"><span class="comment">// 同理等待bar返回</span></span><br><span class="line"><span class="type">Bar</span> <span class="variable">bar</span> <span class="operator">=</span> barFuture.get(); </span><br><span class="line"><span class="comment">// 如果foo需要5秒返回，bar需要6秒返回，实际只需等6秒，即可获取到foo和bar，进行接下来的处理。</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>入口类ServiceBean<br><img data-src="/images/dubbo-provider.jpg" alt="时序图"></p><h4 id="服务消费"><a href="#服务消费" class="headerlink" title="服务消费"></a>服务消费</h4><p>入口类ReferenceBean<br><img data-src="/images/dubbo-consumer.jpg" alt="时序图"></p><h4 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h4><p>暴露服务或取消服务</p><h4 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h4><p>Javassist动态代理生成的代理对象，执行具体的远程调用</p><h4 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h4><p>对多个invoker进行组装</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;高性能RPC框架，主要用于服务治理。包括功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡（默认加权随机）&lt;/li&gt;
&lt;li&gt;集群容错（默认failover）&lt;/li&gt;
&lt;li&gt;服务降级&lt;/li&gt;
&lt;li&gt;监控（Monitor）&lt;ul&gt;
&lt;li&gt;提供者和消费者定时每分钟发送一次统计数据到监控中心&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务注册与发现&lt;br&gt;特点：连通性、健壮性、伸缩性</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>juc并发包</title>
    <link href="http://yoursite.com/2018/08/16/juc/"/>
    <id>http://yoursite.com/2018/08/16/juc/</id>
    <published>2018-08-16T12:52:41.000Z</published>
    <updated>2024-07-31T03:16:37.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul><li>基于AQS实现</li><li>乐观锁</li><li>可中断</li><li>支持公平锁和非公平锁</li><li>可以判断锁状态</li></ul><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><ul><li>类似ReentrantLock</li><li>readLock，读锁，共享锁<ul><li>没有其他线程的写锁</li><li>没有写请求</li><li>有写请求，但调用线程和持有锁的线程是同一个</li></ul></li><li>writeLock，写锁，独占锁<ul><li>没有其他线程的读锁</li><li>没有其他线程的写锁</li></ul></li></ul><h3 id="同步设备"><a href="#同步设备" class="headerlink" title="同步设备"></a>同步设备</h3><h4 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h4><ul><li>同步队列器</li><li>提供了一个FIFO双向队列</li><li>通过UnSafe操作</li></ul><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><ul><li>允许一个或多个线程等待其他线程完成操作</li><li>内部采用AbstractQueuedSynchronizer的共享锁</li><li>采用减计数方式，计数为0时是否所有等待的线程，当计数为0时，计数无法重置，每次调用countDown计数减1，调用await值进行阻塞对计数无影响</li></ul><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><ul><li>可循环使用的屏障</li><li>让一组线程到达一个屏障时阻塞，直到最后一个线程到达屏障时，所有被屏障拦截的线程才会继续执行</li><li>内部采用ReentrantLock实现</li><li>采用加计数方式，计数达到指定值时释放所有等待的线程，计数重置为0重新开始，每次调用await计数加1，若计数不等于指定值，则线程阻塞</li></ul><h4 id="Semphore"><a href="#Semphore" class="headerlink" title="Semphore"></a>Semphore</h4><ul><li>信号量，控制同时访问特定资源的线程数量</li><li>内部实现AbstractQueuedSynchronizer的共享锁</li><li>通过acquire获取一个许可，如果没有就阻塞等待，通过release释放一个许可</li></ul><h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><ul><li>交换者，用于线程间的数据交换，它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据</li></ul><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul><li>默认容量为16，默认并发度16，按照2的幂次方扩容，不能插入key为null和value为null的元素</li><li>JDK1.7<ul><li>分段锁Segment+HashEntry</li><li>size方法<ul><li>先采用不加锁的方式，连续计算元素的个数，最多计算3次，如果前两次计算结果相同，则说明计算出来的元素个数准确；如果不相同，则给每个Segment进行加锁，再计算一次元素的个数</li></ul></li></ul></li><li>JDK1.8<ul><li>Node+CAS+synchronized</li><li>size方法<ul><li>使用volatile类型的变量baseCount记录元素个数，通过addCount()更新baseCount；baseCount+counterCells遍历的value</li></ul></li></ul></li></ul><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicBoolean</li></ul><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicMarkableReference</li></ul><h4 id="字段类"><a href="#字段类" class="headerlink" title="字段类"></a>字段类</h4><ul><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li><li>AtomicStampedReference</li></ul><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h3><p>用于并行执行任务的框架，Fork把一个大任务切分若干个子任务并行的执行，Join合并这些子任务的执行结果，最后得到这个大任务的结果</p><ul><li><p>ForkJoinPool</p><p>ForkJoin框架的任务池，ExecuteService的实现类</p></li><li><p>ForkJoinTask</p><ul><li>Future的子类，框架任务的抽象</li><li><code>RecursiveAction</code> ForkJoinTask的子类，用于没有返回结果的任务</li><li><code>RecursiveTask</code> ForkJoinTask的子类，用于有返回结果的任务</li></ul></li><li><p><code>ForkJoinWorkerThread</code>工作线程</p></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><ul><li>newFixedThreadPool<ul><li>初始化一个核心线程数和最大线程数相同的线程池</li><li>内部使用LinkedBlockingQueue作为阻塞队列</li></ul></li><li>newSingleThreadExecutor<ul><li>初始化只有一个线程的线程池，如果该线程异常结束，会重新开始一个新的线程继续执行任务，可以保证任务提交的顺序</li><li>内部使用LinkedBlockingQueue作为阻塞队列</li></ul></li><li>newCachedThreadPool<ul><li>初始化一个可缓存线程的线程池，默认60s</li><li>内部使用SynchronousQueue作为阻塞队列</li></ul></li><li>newScheduledThreadPool<ul><li>初始化可以在指定时间内周期性的执行所提交的任务</li><li>内部使用DelayedWorkQueue作为阻塞队列</li></ul></li></ul><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><ul><li><code>corePoolSize</code>核心线程池大小</li><li><code>maximumPoolSize</code>最大线程池大小</li><li><code>keepAliveTime</code>线程池中超过corePoolSize数目的空闲线程最大存活时间</li><li><code>TimeUnit</code>keepAliveTime的时间单位</li><li><code>workQueue</code>阻塞任务队列<ul><li><code>ArrayBlockingQueue</code>基于数组的有界阻塞队列，FIFO</li><li><code>LinkedBlockingQueue</code>基于链表的有界阻塞队列，FIFO，吞吐量高于ArrayBlockingQueue</li><li><code>SynchronousQueue</code>不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则一直阻塞，吞吐量通常高于LinkedBlockingQueue</li><li><code>PriorityBlockQueue</code>具有优先级的无界阻塞队列</li><li><code>DelayQueue</code>支持延时获取元素的无界阻塞队列</li></ul></li><li><code>RejectedExecutionHandler</code>任务丢弃策略<ul><li>AbortPolicy（丢弃任务，抛运行时异常）</li><li>CallerRunsPolicy（执行任务）</li><li>DiscardPolicy（忽略）</li><li>DiscardOldestPolicy（从队列中踢出最先进入队列的任务）</li></ul></li><li>threadFactory</li></ul><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul><li><code>Running</code>线程创建后，初始时，处于Running状态</li><li><code>Shutdown</code>调用了shtudown方法，处于shutdown状态，线程池不能接收新的任务，等待所有任务执行完成</li><li><code>Stop</code>调用了shotdownNow方法，处于stop状态，线程池不能接收新的任务，并且尝试终止正在执行的任务</li><li><code>Terminated</code>当线程池处于shutdown和stop状态，并且所有工作线程已经销毁，任务缓存队列已经清空和执行结束后，线程池被置为Terminated状态</li></ul><h4 id="线程数"><a href="#线程数" class="headerlink" title="线程数"></a>线程数</h4><ul><li>通用配置<ul><li>CPU密集型（CPU数目 + 1）</li><li>IO密集型（2 * CPU数目 + 1）</li></ul></li><li>最佳配置<ul><li>((线程等待时间 + 线程CPU时间) &#x2F; 线程CPU时间）* CPU数目</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h3&gt;&lt;h4 id=&quot;ReentrantLock&quot;&gt;&lt;a href=&quot;#ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;Ree</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper（分布式协调服务）</title>
    <link href="http://yoursite.com/2018/08/12/zookeeper/"/>
    <id>http://yoursite.com/2018/08/12/zookeeper/</id>
    <published>2018-08-12T08:06:30.000Z</published>
    <updated>2024-07-31T03:16:37.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ul><li>防止单点故障</li><li>节点数据一致性</li><li>数据恢复</li><li>顺序访问</li><li>高性能</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>分布式锁、负载均衡、注册中心、配置中心</li></ul><h3 id="zoo-cnf配置详解"><a href="#zoo-cnf配置详解" class="headerlink" title="zoo.cnf配置详解"></a>zoo.cnf配置详解</h3><ul><li>tickTime 心跳时间间隔</li><li>initLimit 客户端初始化连接最长多少个tickTime</li><li>syncLimit leader和follower之间发送消息，请求和应答时间最长多少个tickTime</li><li>端口 2181（客户端提供服务）、2888（集群通信端口）:3888（leader选举端口）</li></ul><h3 id="节点特性"><a href="#节点特性" class="headerlink" title="节点特性"></a>节点特性</h3><ul><li>持久节点、持久有序节点、临时节点、临时有序节点</li><li>临时节点和临时有序节点不能有子节点</li><li>同级节点唯一</li></ul><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><h4 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h4><ul><li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li><li>集群内部各服务器的调度者</li></ul><h4 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h4><ul><li>处理客户端非事务请求、转发事务请求给leader</li><li>参与事务请求proposal（提案）的投票</li><li>参与leader选举的投票</li></ul><h4 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h4><ul><li>提供非事务请求服务</li></ul><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><h4 id="选举状态"><a href="#选举状态" class="headerlink" title="选举状态"></a>选举状态</h4><ul><li>LOOKING（初始启动，默认都是LOOKING）</li><li>LEADING</li><li>FOLLOWING</li><li>OBSERVING</li></ul><h4 id="选举参数"><a href="#选举参数" class="headerlink" title="选举参数"></a>选举参数</h4><ul><li>zxid（最大会设置成leader，事务ID越大，表示数据越新）64位<ul><li>前32位是<strong>epoch</strong>编号，每一轮投票，epoch都会递增，每产生一个新的leader，那么新的leader的epoch会+1</li><li>后32位消息计数器（自增），每接收一条消息+1，新leader选举后重置为0</li></ul></li><li>myid（myid越大，在leader选举机制中权重越大）</li></ul><h4 id="选举时机"><a href="#选举时机" class="headerlink" title="选举时机"></a>选举时机</h4><ul><li>启动时leader选举</li><li>leader崩溃时选举</li></ul><h3 id="ZAB协议（基于paxos理论）"><a href="#ZAB协议（基于paxos理论）" class="headerlink" title="ZAB协议（基于paxos理论）"></a>ZAB协议（基于paxos理论）</h3><p>Zookeeper Atomic Broadcast</p><p>支持崩溃恢复的原子广播协议、主要用于实现数据一致性</p><h4 id="原子广播（事务提交，改进版本的2PC）"><a href="#原子广播（事务提交，改进版本的2PC）" class="headerlink" title="原子广播（事务提交，改进版本的2PC）"></a>原子广播（事务提交，改进版本的2PC）</h4><ol><li>leader接收到消息请求后，将消息赋予一个全局唯一的64位自增ID，叫zxid</li><li>leader为每个follower准备了一个FIFO队列，将带有zxid的消息作为一个proposal提案分发给所有的follower</li><li>当follower接收到proposal，先把proposal写到磁盘，写入成功以后再向leader回复一个ack</li><li>当leader接收到合法数量（超过半数节点）的ack后，leader就会向这些follower发送commit命令，同时会再本地执行该消息</li><li>当follower收到消息的commit命令以后，会提交该消息</li></ol><h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><ol><li>当leader失去了过半的follower节点的连续</li><li>当leader服务挂了</li></ol><p>集群就会进入崩溃恢复阶段，对于数据恢复来说：</p><ol><li><p>已经被处理的消息不能丢失</p><p>当leader收到合法数量的follower的ack之后，就会向各个follower广播消息（commit命令）同时自己也会commit这条事务消息，如果follower节点收到commit命令之前，leader挂了，会导致部分节点收到commit，部分节点没有收到，那么zab协议需要保证已经被处理的消息不能丢失。</p></li><li><p>被丢弃的消息不能再次出现</p><p>当leader收到事务请求，并且还未发起事务投票之前，leader挂了，此次消息必须全部丢失</p></li></ol><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><h4 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h4><ul><li>world（所有人都能访问）</li><li>auth（不使用任何id，代表任何已认证的用户）</li><li>digest（用户名和密码验证）</li><li>ip（ip验证，格式addr&#x2F;bits）</li></ul><h4 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h4><ul><li>CREATE（创建权限，可以创建子节点，create，exists，getChildren，delete）</li><li>DELETE （删除权限，可以删除子节点，create，exists，getChildren，delete）</li><li>READ （读权限，可以获取节点和子节点列表，create，exists，getData，getChildren，delete）</li><li>WRITE （写权限，create，exists，getChildren，setData，delete）</li><li>ADMIN （管理权限，create，exists，getChildren，delete）</li></ul><h3 id="Watch机制"><a href="#Watch机制" class="headerlink" title="Watch机制"></a>Watch机制</h3><h4 id="watcher特性"><a href="#watcher特性" class="headerlink" title="watcher特性"></a>watcher特性</h4><ul><li>watcher是一次性的操作<ul><li>当数据发生变化时，zookeeper会产生一个watcher事件，并且会发送到客户端，但是客户端只会收到一次通知。如果后续这个节点再次发生变化，那么之前设置watcher的客户端不会再次收到消息。</li></ul></li><li>可以通过循环监听达到永久监听效果</li></ul><h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><ul><li>None 客户端连接状态发生变化的时候，会收到none的事件</li><li>NodeCreated 创建节点事件</li><li>NodeDeleted 删除节点事件</li><li>NodeDataChanged 节点数据发生变更</li><li>NodeChildrenChanged 子节点被创建、删除会发生</li></ul><h4 id="如何注册事件机制"><a href="#如何注册事件机制" class="headerlink" title="如何注册事件机制"></a>如何注册事件机制</h4><ul><li>绑定事件<ul><li>getData、Exists、getChildren</li></ul></li><li>触发事件<ul><li>create、delete、setData</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;设计思想&quot;&gt;&lt;a href=&quot;#设计思想&quot; class=&quot;headerlink&quot; title=&quot;设计思想&quot;&gt;&lt;/a&gt;设计思想&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;防止单点故障&lt;/li&gt;
&lt;li&gt;节点数据一致性&lt;/li&gt;
&lt;li&gt;数据恢复&lt;/li&gt;
&lt;li&gt;顺序访问&lt;/li&gt;</summary>
      
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://yoursite.com/2018/08/10/mysql/"/>
    <id>http://yoursite.com/2018/08/10/mysql/</id>
    <published>2018-08-10T12:50:34.000Z</published>
    <updated>2024-07-31T03:16:37.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul><li><p>插入缓冲（提高写性能）</p><p>对于非聚集类所有的插入和更新操作，不是每一次都直接插入到索引页中，而是先插入到内存中</p></li><li><p>自适应哈希索引（提高查询效率）</p><p>监控对表上各索引页的查询，如果观察到建立哈希索引可以带来速度提升，则会建立哈希索引，称为自适应哈希索引（Adaptive Hash Index，AHI）</p></li><li><p>两次写（提高可靠性）</p><p>当属性缓冲池脏页时，并不直接写道数据库文件中，而是先拷贝至内存中的两次写缓冲区，接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入1M，再将两次写缓冲区写入数据文件</p></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>支持事务处理，ACID事务特性</li><li>实现了SQL标准的四种隔离级别</li><li>支持行锁和外键约束</li><li>可以利用事务日志进行数据恢复</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不支持FULLTEXT类型的索引，因为它没有保存表的行数</li><li>当使用count统计时会扫描全表</li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>高性能读取</li><li>保存了表的行数，当使用count统计时不会扫描全表</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不支持事务</li><li>不支持行锁和外键</li><li>Insert和Update操作需要锁定整个表</li><li>不支持故障恢复</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h4><ul><li>每个节点包含了键值和键值对应的数据对象存放地址指针</li><li>根节点常驻内存</li><li>同一键值不会出现多次，并且它有可能出现在叶节点，也有可能出现在非叶节点中</li><li>最小时间复杂度为1</li><li>适合内存</li></ul><h4 id="B-tree-1"><a href="#B-tree-1" class="headerlink" title="B+tree"></a>B+tree</h4><ul><li>非叶节点中存放的关键码并不指向数据对象的地址指针，非叶节点只是索引部分</li><li>键一定会出现在叶节点中，并且有可能在非叶节点中，也有可能重复出现，以维持B+树的平衡</li><li>时间复杂度固定</li><li>适合硬盘</li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><ul><li>仅能满足&#x3D;、in、&lt;&#x3D;、&gt;查询，不能使用范围查询</li><li>无法被用来避免数据的排序操作</li><li>索引在任何时候都不能避免表扫描</li><li>Hash冲突时性能低</li></ul><h4 id="FullText"><a href="#FullText" class="headerlink" title="FullText"></a>FullText</h4><ul><li>全文搜索的索引<ul><li>倒排索引<ul><li>以字或词为关键字索引，关键字记录了所有存在关键字的文档</li></ul></li><li>正排索引<ul><li>以文档的ID为关键字，表中记录文档中的每个字的位置信息，查找每个文档中字的信息知道找出所有包含关键字的文档</li></ul></li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>索引不会包含有null值的列</li><li>使用短索引</li><li>索引列like语句前面不要加%</li><li>不要再列上进行运算</li><li>索引要建再经常select操作的字段上</li><li>索引要建在值比较唯一的字段上，text、image、bit数据类型的列不应该增加索引</li><li>不能使用not in、&lt;&gt;、!&#x3D;等负向条件</li><li>如果明确知道只有一条结果返回，limit 1能够提高效率</li><li>强制类型转换会全表扫描</li><li>遵循最左前缀原则</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><ul><li>MyISAM<ul><li>表锁</li></ul></li><li>InnoDB<ul><li>表锁</li><li>行锁<ul><li>只有通过索引条件检索数据，才能使用行锁，否则将使用表锁</li><li>只有执行计划真正使用了索引，才能使用行锁；即便在条件中使用了索引字段，但是如果Mysql认为全表扫描效率更高，那么就不会使用索引，这种情况下将使用表锁</li></ul></li><li>意向锁</li><li>间隙锁</li></ul></li><li>BDB<ul><li>表锁</li><li>页锁</li></ul></li></ul><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><ul><li>共享锁（读锁）<ul><li>读锁不会阻塞同一表的其他读请求，会阻塞同一表写请求</li><li>加锁：select lock in share mode</li></ul></li><li>排他锁（写锁）<ul><li>写锁会阻塞其他同一表的读和写操作</li><li>insert、update、remove自动加锁</li><li>加锁：select *** for update</li></ul></li></ul><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul><li><p>表锁</p><p>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度低</p></li><li><p>行锁</p><p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高</p></li><li><p>页锁</p><p>开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</p></li><li><p>间隙锁</p><p>当我们用范围条件检索数据，并请求共享和排他锁时，对于键值在条件范围内但并不存在的记录，叫做间隙，InnoDB也会对这个间隙加锁，这种锁就叫间隙锁。</p><ul><li>可以防止幻读</li></ul></li><li><p>意向锁</p><p>表级锁，但是却表示事务正在读或写某一行记录，而不是整个表，在给一行记录加锁前，首先要给该表加意向锁</p></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>原子性（Atomicity）事务包含的操作要么全部成功，要么全部失败</li><li>一致性（Consistency）事务必须使数据库从一个一致性状态变换成另一个一致性状态</li><li>隔离性（Isolation）多个并发事务之间相互隔离</li><li>持久性（Durability）一个事务一旦被提交了，那么数据库中数据的改变就是永久性的</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>读未提交（Read UnCommited）<ul><li>造成脏读、不可重复读、幻读</li></ul></li><li>读已提交（Read Commited）</li><li>造成不可重复读、幻读</li><li>可重复读（Repeatable Read）</li><li>造成幻读</li><li>串行化读（Serializable）</li></ul><h3 id="隔离级别问题"><a href="#隔离级别问题" class="headerlink" title="隔离级别问题"></a>隔离级别问题</h3><ul><li>脏读<ul><li>在一个事务处理过程中读取到了另一个未提交的事务中的数据</li></ul></li><li>不可重复读<ul><li>一个事务范围内多次查询却返回了不同的数据，这是由于查询间隔期间，其他事务修改并提交了</li></ul></li><li>幻读<ul><li>事务非独立执行时发生的一种现象<ul><li>事务A查询数据没有数据1，插入数据1</li><li>事务B查询数据没有数据1，插入数据1，提交事务</li><li>事务A提交事务，发现提交失败，提示已经存在1</li></ul></li></ul></li></ul><h2 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h2><ul><li><code>max_connections</code> 最大连接数</li><li><code>open_files_limit</code> 打开的文件描述符限制，默认最小1024，当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个</li><li><code>read_buffer_size</code> 读入缓冲区大小</li><li><code>read_rnd_buffer_size</code> 随机读缓冲区大小</li><li><code>sort_buffer_size</code> 执行排序使用的缓冲大小</li><li><code>join_buffer_size</code> 联合查询操作所能使用的缓冲区大小</li><li><code>thread_cache_size</code> 表示可以重新利用保存在缓存中线程的数量</li><li><code>query_cache_size</code> 查询缓冲大小</li><li><code>query_cache_limit</code> 指定单个查询能够使用的缓冲区大小，默认1M</li><li><code>key_buffer_size</code> 指定用于索引的缓冲区大小</li><li><code>slow_query_log</code> 开启慢查询</li><li><code>long_query_time</code> 慢查询时间 超过1秒则为慢查询</li><li><code>lower_case_table_names</code> 不区分大小写</li><li><code>innodb_open_files</code> 限制Innodb能打开的表的数据</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li><p>drop、truncate、delete的区别？</p><ul><li>truncate和delete值删除数据不删除表结构，drop将删除表结构</li><li>truncate和drop是数据库定义语言，操作立即生效，delete需要事务提交之后才生效</li><li>速度：drop &gt; truncate &gt; delte</li></ul></li><li><p>数据库优化方案</p><ul><li>读写分离</li><li>分库分表</li><li>使用索引</li><li>开启慢查询</li></ul></li><li><p>什么是redo日志？什么是undo日志？</p><ul><li>Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据</li><li>Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；</li></ul></li><li><p>聚集索引和非聚集索引的区别</p><ul><li>聚集索引表记录的排列顺序和索引的排列顺序一致，并且只能有一个</li><li>非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致；可以存在多个</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h2&gt;&lt;h3 id=&quot;InnoDB&quot;&gt;&lt;a href=&quot;#InnoDB&quot; class=&quot;headerlink&quot; title=&quot;InnoD</summary>
      
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>MQ</title>
    <link href="http://yoursite.com/2018/08/03/mq/"/>
    <id>http://yoursite.com/2018/08/03/mq/</id>
    <published>2018-08-03T12:23:52.000Z</published>
    <updated>2024-07-31T03:16:37.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>Java消息服务（Java Message Service）是Java平台中关于面向消息中间件的API。JMS是一个与平台无关的API，绝大多数<strong>MOM</strong>提供商都对JMS提供了支持。</p><h3 id="消息组成"><a href="#消息组成" class="headerlink" title="消息组成"></a>消息组成</h3><ul><li>消息头<ul><li>消息的识别信息和路由信息<ul><li>JMS Destination 消息发送的目的地，queue或topic</li><li>JMS DeliveryMode 传送模式，持久模式或非持久模式</li><li>JMS Priority 消息优先级，分为10个级别，从0（最低）到9（最高），默认级别是4，不保证一定按照优先级的顺序提交消息</li><li>JMS MessageID 唯一识别每个消息的标识</li></ul></li></ul></li><li>属性<ul><li>应用程序自定义的属性，<code>Message.setStringProperty(key,value)</code></li><li>JMS定义的属性，使用JMSX作为前缀</li></ul></li><li>消息体<ul><li>TextMessage<code>Java.lang.String</code>对象</li><li>MapMessage 键&#x2F;值对的集合，键是<code>Java.lang.String</code>对象，值可以是Java任何基本类型</li><li>BytesMessage 字节流</li><li>StreamMessage Java中的输入&#x2F;输出流</li><li>ObjectMessage Java中的可序列化对象</li><li>Message 没有消息体，只有消息头和属性</li></ul></li></ul><h3 id="消息传递域"><a href="#消息传递域" class="headerlink" title="消息传递域"></a>消息传递域</h3><ul><li>点对点（point-to-point）消息传递域<ul><li>每个消息只能有一个消费者</li><li>生产者和消费者之间<strong>没有</strong>时间上的相关性</li></ul></li><li>发布&#x2F;订阅（publish&#x2F;subscribe）消息传递域<ul><li>每个消息可以有多个消费者</li><li>生产者和消费者之间<strong>有</strong>时间上的相关性</li></ul></li></ul><h3 id="消息应答模式"><a href="#消息应答模式" class="headerlink" title="消息应答模式"></a>消息应答模式</h3><h4 id="ACK-MODE"><a href="#ACK-MODE" class="headerlink" title="ACK_MODE"></a>ACK_MODE</h4><ul><li>AUTO_ACKNOWLEDGE&#x3D;1  自动确认</li><li>CLIENT_ACKNOWLEDGE&#x3D;2  客户端收到确认，客户端调用消息的acknowledge方法确认消息</li><li>DUPS_OF_ACKNOWLEDGE&#x3D;3  自动批量确认</li><li>SESSION_TRANSACTED&#x3D;0  事务提交并确认</li></ul><h4 id="ACK-TYPE"><a href="#ACK-TYPE" class="headerlink" title="ACK_TYPE"></a>ACK_TYPE</h4><ul><li>DELIVERED_ACK_TYPE &#x3D; 0 消息”已接收”，但尚未处理结束</li><li>POSION_ACK_TYPE &#x3D; 1 消息”错误”,通常表示”抛弃”此消息，比如消息重发多次后，都无法正确处理时，消息将会被删除或者 DLQ(死信队列) </li><li>STANDARD_ACK_TYPE &#x3D; 2 “标准”类型,通常表示为消息”处理成功”，broker 端 可以删除消息</li><li>REDELIVERED_ACK_TYPE &#x3D; 3 消息需”重发”，比如 consumer 处理消息时抛出了异常，broker 稍后会重新发送此消息 </li><li>INDIVIDUAL_ACK_TYPE &#x3D; 4 表示只确认”单条消息”,无论在任何 ACK_MODE 下</li><li>UNMATCHED_ACK_TYPE &#x3D; 5 在 Topic 中，如果一条消息在转发给“订阅者”时，发现此消息不符合 Selector 过滤条件，那么此消息将不会转发给订阅者，消息将会被存储引擎删除(相当于在 Broker 上确认了消息)</li></ul><h3 id="MOM"><a href="#MOM" class="headerlink" title="MOM"></a>MOM</h3><p>面向消息中间件（Message Oriente Middleware）</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>消息异步接收，发送者不需要等待消息接收者响应</li><li>消息可靠接收，确保消息在中间件可靠保存。只有接收者收到后才删除消息。</li></ol><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><p>完全基于JMS规范实现的一个消息中间件，主要应用在分布式系统架构中，帮助构建高可用、高性能、可伸缩的企业级面向消息服务的系统</p><p>特性</p><ul><li>支持多语言和协议<ul><li>OpenWire</li><li>Stomp</li><li>AMQP</li><li>MQTT</li></ul></li><li>完全支持jms1.1和J2ee1.4规范</li><li>对spring的支持</li></ul><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>提供消息服务的组件</p><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><ul><li>当broker发送消息给订阅者时，如果订阅者处于未激活状态，<ul><li>持久订阅者可以收到消息</li><li>非持久订阅则收不到消息</li></ul></li></ul><h3 id="消息发送策略"><a href="#消息发送策略" class="headerlink" title="消息发送策略"></a>消息发送策略</h3><ul><li>同步发送<ul><li>发送者发送一条消息会阻塞直到broker反馈一个确认消息，表示消息已经被broker处理</li></ul></li><li>异步发送<ul><li>发送者不需要等待broker提供反馈</li></ul></li></ul><p>默认情况下，非持久化消息是异步发送的，持久化消息并且在非事务模式下是同步发送的，开启事务的情况下，消息都是异步发送</p><h3 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h3><h5 id="KahaDB（默认存储策略）"><a href="#KahaDB（默认存储策略）" class="headerlink" title="KahaDB（默认存储策略）"></a>KahaDB（默认存储策略）</h5><ul><li><p>配置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>存储文件</p><ul><li>db.data 消息的索引文件</li><li>db.redo 用来进行消息恢复</li><li>db-*.log 存储消息内容</li><li>lock文件 锁，表示当前获得kahadb读写权限的broker</li></ul></li></ul><h5 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h5><ul><li><p>配置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jdbcPersistenceAdapter</span> <span class="attr">dataSource</span>=<span class="string">&quot;#MySQL-DS&quot;</span> <span class="attr">createTablesOnStartup</span>=<span class="string">&quot;true&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Mysql-DS&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activemq? relaxAutoCommit=true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用JDBC持久化方式，数据库会创建3个表：activemq_msgs，activemq_acks和activemq_lock</p><ul><li>ACTIVEMQ_MSGS 消息表，queue和topic都存在这个表</li><li>ACTIVEMQ_ACKS 存储持久订阅的信息和最后一个持久订阅接收的消息ID</li><li>ACTIVEMQ_LOCKS 锁表，用来确保某一时刻，只能有一个ActiveMQ broker实例来访问数据库</li></ul></li></ul><h5 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h5><ul><li><p>基于内存的消息存储，内存消息存储主要是存储所有的持久化的消息在内存中，<code>persistent=&quot;false&quot;</code>表示不设置持久化存储，直接存储到内存中</p></li><li><p>配置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">broker</span> <span class="attr">brokerName</span>=<span class="string">&quot;test-broker&quot;</span> <span class="attr">persistent</span>=<span class="string">&quot;false&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://activemq.apache.org/schema/core&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://localhost:61635&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">broker</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h5><ul><li><p>配置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    &lt;levelDBdirectory=&quot;activemq-data&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="JDBC-With-ActiveMQ-Journal"><a href="#JDBC-With-ActiveMQ-Journal" class="headerlink" title="JDBC With ActiveMQ Journal"></a>JDBC With ActiveMQ Journal</h5><ul><li><p>这种方式克服了JDBC Store的不足，JDBC每次消息过来，都需要写库和读库，而Journal使用了高速缓存写入技术，大大提高了性能。</p></li><li><p>配置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceFactory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">journalPersistenceAdapterFactory</span>  <span class="attr">dataSource</span>=<span class="string">&quot;#Mysql-DS&quot;</span> <span class="attr">dataDirectory</span>=<span class="string">&quot;activemqdata&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceFactory</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>prefetchSzie<ul><li>持久化queue和非持久化queue的默认值为1000</li><li>持久化topic默认值100</li><li>非持久化topic默认值Short.MAX_VALUE</li></ul></li></ul><p>消费者会根据prefetchSize的大小批量获取数据，比如默认值1000，那么消费者会预先加载1000条数据到本地内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Destination destination=session.createQueue(<span class="string">&quot;myQueue?consumer.prefetchSize=10&quot;</span>); </span><br></pre></td></tr></table></figure><ul><li>optimizeAcknowledge<ul><li>优化确认，表示是否开启“优化ACK”，只有在true情况下，prefetchSize和optimizeAcknowledgeTimeOut才有意义</li><li>减轻客户端负担，不需要频繁的确认消息</li><li>减少通信开销</li><li>由于延迟了确认（默认ack 0.65*prefetchSize个消息才确认），broker再次发送消息时又可以批量发送</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(<span class="string">&quot;tcp://192.168.0.18:61616?jms.optimizeAcknowledge=true&amp;jms.optimizeAcknowledgeTimeOut=10000&quot;</span>); </span><br></pre></td></tr></table></figure><p>如果optimizeAcknowledge为true，那么prefetchSize必须大于0。当prefetchSize&#x3D;0的时候，表示consumer 通过PULL方式从broker获取消息。</p><h3 id="消息重发"><a href="#消息重发" class="headerlink" title="消息重发"></a>消息重发</h3><h4 id="重发时机"><a href="#重发时机" class="headerlink" title="重发时机"></a>重发时机</h4><ul><li>在事务性会话中，没有调用 session.commit 确认消息或者调用session.rollback 方法回滚消息</li><li>在非事务性会话中，ACK 模式为 CLIENT_ACKNOWLEDGE 的情况下，没有调用 acknowledge 或者调用了 recover 方法；</li></ul><p>一个消息被redelivedred超过默认的最大重发次数（默认 6 次）时，消费端会给 broker 发送一个poisonack，表示这个消息有毒，告诉 broker 不要再发了。这个时候 broker 会把这个消息放到 DLQ（<strong>死信队列</strong>）。 </p><h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><p>死信队列可以再次消费</p><p>配置策略</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">destinationPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyMap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">topic</span>=<span class="string">&quot;&gt;&quot;</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pendingMessageLimitStrategy</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constantPendingMessageLimitStrategy</span> <span class="attr">limit</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pendingMessageLimitStrategy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- “&gt;”表示对所有队列生效，如果需要设置指定队列，则直接写队列名称  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">queue</span>=<span class="string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">queuePrefix:设置死信队列前缀</span></span><br><span class="line"><span class="comment">useQueueForQueueMessage 设置队列保存到死信。  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">individualDeadLetterStrategy</span> <span class="attr">queuePrefix</span>=<span class="string">&quot;DLQ.&quot;</span> <span class="attr">useQueueForQueueMessages</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">destinationPolicy</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自动丢弃过期消息"><a href="#自动丢弃过期消息" class="headerlink" title="自动丢弃过期消息"></a>自动丢弃过期消息</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sharedDeadLetterStrategy</span> <span class="attr">processExpired</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span> </span><br></pre></td></tr></table></figure><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="静态网络"><a href="#静态网络" class="headerlink" title="静态网络"></a>静态网络</h4><p>两个 Brokers 通过一个 static 的协议来进行网络连接。一个 Consumer 连接到BrokerB 的一个地址上，当 Producer 在 BrokerA 上以相同的地址发送消息是，此时消息会被转移到 BrokerB 上，也就是说 BrokerA 会转发消息到BrokerB 上 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置activemq地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">networkConnectors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">networkConnector</span> <span class="attr">uri</span>=<span class="string">&quot;static://(tcp://192.168.11.153:61616,tcp://192.168.11.154:61616)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">networkConnectors</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消息回流 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- enableAudit=false,防止消息回流后被当作重复消息而不被分发  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">queue</span>=<span class="string">&quot;&gt;&quot;</span> <span class="attr">enableAudit</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">networkBridgeFilterFactory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- replayWhenNoConsumers=true, 当broker1上有需要转发的消息但是没有消费者时，把消息回流到它原始的broke  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">conditionalNetworkBridgeFilterFactory</span> <span class="attr">replayWhenNoConsumers</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">networkBridgeFilterFactory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="动态网络"><a href="#动态网络" class="headerlink" title="动态网络"></a>动态网络</h4><p>ActiveMQ 使用 Multicast 协议将一个 Service 和其他的 Broker 的 Service 连接起来。Multicast 能够自动的发现其他 broker，从而替代了使用 static 功能列表 broker。</p><h3 id="ActiveMQ优缺点"><a href="#ActiveMQ优缺点" class="headerlink" title="ActiveMQ优缺点"></a>ActiveMQ优缺点</h3><p>ActiveMQ 采用消息推送方式，所以最适合的场景是默认消息都可在短时间内被消费。数据量越大，查找和消费消息就越慢，消息积压程度与消息速度成反 比。 </p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>吞吐量低</strong>，由于 ActiveMQ 需要建立索引，导致吞吐量下降。这是无法克服的缺点，只要使用完全符合 JMS 规范的消息中间件，就要接受这个级别的TPS</li><li><strong>无分片功能</strong>，这是一个功能缺失，JMS 并没有规定消息中间件的集群、分片机制。而由于 ActiveMQ 是伟企业级开发设计的消息中间件，初衷并不是为了处理海量消息和高并发请求。如果一台服务器不能承受更多消息，则需要横向拆分。ActiveMQ 官方不提供分片机制，需要自己实现</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>对 TPS 要求比较低的系统，可以使用 ActiveMQ 来实现，一方面比较简单，能够快速上手开发，另一方面可控性也比较好，还有比较好的监控机制和界面 </p><h4 id="不适应场景"><a href="#不适应场景" class="headerlink" title="不适应场景"></a>不适应场景</h4><p>消息量巨大的场景。ActiveMQ 不支持消息自动分片机制，如果消息量巨大， 导致一台服务器不能处理全部消息，就需要自己开发消息分片功能</p><h2 id="Kafka（未完待续）"><a href="#Kafka（未完待续）" class="headerlink" title="Kafka（未完待续）"></a>Kafka（未完待续）</h2><p>分布式消息和订阅系统，高性能、高吞吐量</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>行为跟踪</li><li>日志收集</li></ul><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>topic是一个存储消息的逻辑概念，可以认为是一个消息集合。每条消息发送到 kafka 集群的消息都有一个类别。物理上来说，不同的 topic 的消息是分开存储的。</p><h3 id="Partition（分区）"><a href="#Partition（分区）" class="headerlink" title="Partition（分区）"></a>Partition（分区）</h3><p>每个 topic 可以划分多个分区（每个 Topic 至少有一个分区），同一topic下的不同分区包含的消息是不同的。每个消息在被添加到分区时，都会被分配一个offset（称之为偏移量），它是消息在此分区中的唯一编号，kafka通过offset保证消息在分区内的顺序，offset的顺序不跨分区，即<strong>kafka只保证在同一个分区内的消息是有序的</strong>。</p><ul><li><p>消费者比Partition多，会造成资源浪费</p></li><li><p>Partition比消费者多，消费者会消费多个Partition</p></li><li><p>只能保证单个Partition的消息顺序，不能保证多个Partition的顺序</p></li></ul><h4 id="分发机制"><a href="#分发机制" class="headerlink" title="分发机制"></a>分发机制</h4><p>默认情况，kafka采用的是hash取模的分区算法。如果key为null，则会在<code>metadata.max.age.ms</code>时间范围内随机分配一个分区。<code>”metadata.max.age.ms</code>默认情况下10分钟更新一次。也可以自定义key的分区分配。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>对broker上的数据进行分片有效的减少了消息的容量，从而提升了io性能</li><li>提高消费端的消费能力（消费端可以采用负载均衡的方式消费不同分区消息）</li></ul><h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><ul><li>Range（范围分区，默认）<ul><li>首先按照分区序号进行排序，并对消费者按照字典顺序进行排序。</li><li>按照消费者总数和分区总数进行整除运算来获得一个跨度，然后将分区按照跨度进行平均分配，以保证分区尽可能均匀地分配给所有的消费者。如果不够平均分配，那么字典序靠前的消费者会被多分配一个分区。</li></ul></li><li>RoundRobin（轮询）<ul><li>轮询分区策略是把所有partition和所有consumer线程都列出来，然后按照 hashcode 进行排序。最后通过轮询算法分配partition给消费线程。如果所有consumer实例的订阅是相同的，那么partition会均匀分布。</li></ul></li><li>自定义策略<ul><li>继承AbstractPartitionAssignor，实现对应的方法即可。</li></ul></li></ul><h4 id="分配策略触发时机"><a href="#分配策略触发时机" class="headerlink" title="分配策略触发时机"></a>分配策略触发时机</h4><ol><li>同一个consumer group内新增了消费者 </li><li>消费者离开当前所属的 consumer group，比如主动停机或者宕机</li><li>topic新增了分区（也就是分区数量发生了变化）</li></ol><h4 id="高可用副本机制"><a href="#高可用副本机制" class="headerlink" title="高可用副本机制"></a>高可用副本机制</h4><p>为了提高partition的可靠性而提供了副本的概念（Replica） ,通过副本机制来实现冗余备份。每个分区可以有多个副本，并且在副本集合中会存在一个 leader的副本，所有的读写请求都是由leader副本来进行 处理。剩余的其他副本都做为 follower 副本，follower 副 本会从 leader 副本同步消息日志。一般情况下，同一个分区的多个副本会被均匀分配到集群中的不同broker上，当leader副本所在的broker出现故障后，可以重新选举新的 leader 副本继续对外提供服务。 通过这样的副本机制来提高kafka集群的可用性</p><h5 id="副本分配算法"><a href="#副本分配算法" class="headerlink" title="副本分配算法"></a>副本分配算法</h5><ol><li><p>将所有N Broker和待分配的i个Partition排序。</p></li><li><p>将第i个Partition分配到第(i mod n)个Broker上。</p></li><li><p>将第i个Partition的第j个副本分配到第((i + j) mod n)个 Broker上。</p></li></ol><h5 id="副本角色"><a href="#副本角色" class="headerlink" title="副本角色"></a>副本角色</h5><ul><li><p>leader副本：响应clients端读写请求的副本 </p></li><li><p>follower副本：被动地备份leader副本中的数据，不能响 应clients端读写请求。 </p></li><li><p>ISR副本：包含了leader副本和所有与leader副本保持同步的 follower 副本。表示目前“可用且消息量与 leader 相差不多的副本集合， 这是整个副本集合的一个子集”。ISR集合中的副本必须满足两个条件：</p><ol><li><p>副本所在节点必须维持着与zookeeper的连接 </p></li><li><p>副本最后一条消息的 offset 与 leader 副本的最后一条消息的 offset 之间的差值不能超过指定的阈值 (replica.lag.time.max.ms) 。如果该 follower 在此时间间隔内一直没有追上过leader的所有消息，则该follower就会被剔除isr列表</p></li></ol></li></ul><p>——如何判定是否与 leader 同步后面会提到每个 Kafka 副本对象都有两个重要的属性：LEO 和 HW。注意是所有的副本，而不只是leader副本。 </p><h6 id="副本对象属性"><a href="#副本对象属性" class="headerlink" title="副本对象属性"></a>副本对象属性</h6><ul><li>LEO：日志末端位移（log end offset），记录了该副本底层日志(log)中下一条消息的位移值。</li><li>HW：水位值（HighWatermark），HW标记了一个特殊的offset，当消费者处理消息的时候，只能拉取到HW之前的消息，HW之后的消息对消费者来说是不可见的。对于同一个副本对象而言，其HW值不会大于LEO值。小于等于HW值的所有消息都被认为是“已备份”的（replicated）</li></ul><p>Kafka 提供了数据复制算法保证，如果 leader 发生故障或挂掉，一个新leader被选举并被接受客户端的消息成功写 入。Kafka确保从同步副本列表中选举一个副本为leader； leader 负责维护和跟踪 ISR(in-Sync replicas ， 副本同步 队列)中所有 follower 滞后的状态。当 producer 发送一条 消息到broker后，leader写入消息并复制到所有follower。 消息提交之后才被成功复制到所有的同步副本。 </p><h4 id="多个分区在集群的中的分配"><a href="#多个分区在集群的中的分配" class="headerlink" title="多个分区在集群的中的分配"></a>多个分区在集群的中的分配</h4><ol><li><p>将所有N Broker和待分配的i个Partition排序</p></li><li><p>将第i个Partition分配到第(i mod n)个Broker上</p></li></ol><h3 id="消息写入性能"><a href="#消息写入性能" class="headerlink" title="消息写入性能"></a>消息写入性能</h3><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><h3 id="常用配置解析"><a href="#常用配置解析" class="headerlink" title="常用配置解析"></a>常用配置解析</h3><h4 id="提供者端"><a href="#提供者端" class="headerlink" title="提供者端"></a>提供者端</h4><ul><li><code>acks</code> 表示producer发送消息到broker的确认机制<ul><li>0：表示producer不需要等待broker的消息确认，时延最小但风险最大（server宕机时，数据会丢失）</li><li>1：表示producer只需要获得kafka集群中的leader节点确认即可，时延较小同时保证了leader节点确认接收成功</li><li>-1：需要ISR中所有的Replica给予接收确认，速度最慢，安全性最高，不能避免数据丢失</li></ul></li><li><code>batch.size</code> 控制批量提交的字节数大小，默认16384byte，也就是16kb，可以减少网络请求带来的性能开销</li><li><code>linger.ms</code> producer发送消息到broker的时间间隔，producer会把两次发送时间间隔内收集到的request进行一次聚合 然后再发送，以此提高吞吐量。<ul><li>batch.size和linger.ms这个两个参数是kafka性能优化的关键参数，当两者都配置时，只有满足一个条件，就会发送请求到broker</li></ul></li><li><code>max.request.size</code> 设置请求的数据最大字节数，默认值为1MB</li></ul><h4 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h4><ul><li><code>group.id</code> consumer group是kafka提供的可扩展且具有容错性的消费者机制。一个gourp中可以又多个consumer，它们共享一个groupd.id。每个分区只能由同一个消费组内的一个 consumer 来消费。<ul><li>同一个topic<ul><li>相同分区<ul><li>相同group，只能有一个consumer消费消息</li><li>不同group，每个group只能有一个consumer消费消息</li></ul></li><li>不同分区<ul><li>相同gorup，每个consumer根据<strong>策略</strong>消费不同分区的消息</li><li>不同group，每个group都可以消费不同分区所有的消息</li></ul></li></ul></li></ul></li><li><code>enable.auto.commit</code> 消费者消费消息后是否自动提交，可以配合 auto.commit.interval.ms 控制自动提交的频率<ul><li><code>true </code> 自动提交</li><li><code>false</code> 手动提交，需调用consumer的commitSync()方法来提交</li></ul></li><li><code>auto.offset.rest</code> <ul><li><code>latest</code> 新的消费者将会从其他消费者最后消费的offset 处开始消费 Topic 下的消息 </li><li><code>earliest</code> 新的消费者会从该 topic 最早的消息开始 </li><li><code>none</code> 新的消费者加入以后，由于之前不存在offset，则会直接抛出异常。</li></ul></li><li><code>max.poll.records</code> 设置限制每次调用 poll 返回的消息数，这样可以更容易的预测每次 poll 间隔要处理的最大值，通过调整此值，可以减少 poll 间隔</li><li><code>partition.assignment.strategy</code> 分区分配策略，客户端使用该配置策略在消费者之间分配分区使用权</li></ul><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>Advanced Message Queuing Protocol</p><p>跨语言</p><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>Message Queuing Telemetry Transport</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JMS&quot;&gt;&lt;a href=&quot;#JMS&quot; class=&quot;headerlink&quot; title=&quot;JMS&quot;&gt;&lt;/a&gt;JMS&lt;/h2&gt;&lt;p&gt;Java消息服务（Java Message Service）是Java平台中关于面向消息中间件的API。JMS是一个与平台无关的AP</summary>
      
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>缓存之Redis详解</title>
    <link href="http://yoursite.com/2018/07/27/redis/"/>
    <id>http://yoursite.com/2018/07/27/redis/</id>
    <published>2018-07-27T07:23:52.000Z</published>
    <updated>2024-07-31T03:16:37.261Z</updated>
    
    <content type="html"><![CDATA[<p>Redis本质上是一个Key-Value类型的内存数据库，很像Memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不行Memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比如说用他的List来做FIFO双向链表，实现一个轻量级的高性能消息队列服务，用它的Set可以做高性能的tag系统等待。另外Redis也可以对存入的Key-Value设置expire时间，因此可以被当作一个功能加强版的Memcached来用。<br>Redis的主要缺点是数据库容量收到物理内存的限制，不能用作海量数据的高性能读写，因此Redis时候的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="Redis单线程为什么性能很高"><a href="#Redis单线程为什么性能很高" class="headerlink" title="Redis单线程为什么性能很高"></a>Redis单线程为什么性能很高</h3><p>性能瓶颈不在CPU，在内存和网络带宽</p><p>IO多路复用</p><h3 id="数据结构类型"><a href="#数据结构类型" class="headerlink" title="数据结构类型"></a>数据结构类型</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>sds（simple dynamic string）简单动态字符串</li><li>dict 维护key-value映射关系</li><li>quicklist</li><li>ziplist</li><li>skiplist</li><li>robj</li><li>intset</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><code>String</code>最大支持512M<ul><li>字符串、浮点（set&#x2F;get）<ul><li>数据结构sds</li></ul></li><li>整数（incr&#x2F;decr）<ul><li>数据结构int</li></ul></li></ul></li><li>Hash<ul><li>hset&#x2F;hget&#x2F;hexists</li><li>数据结构<ul><li><code>ziplist</code>个数少或单个元素长度小</li><li>hash</li></ul></li></ul></li><li>List<ul><li>lpush&#x2F;rpush&#x2F;lpop&#x2F;rpop&#x2F;llen</li><li>数据结构，在3.2版本<ul><li>之前<ul><li><code>linkedlist</code>双向链表，个数多或单个元素长度长</li><li><code>ziplist</code> 压缩列表，个数少或单个元素长度小</li></ul></li><li>之后<ul><li><code>quicklist</code>基于<code>ziplist</code>的双向链表</li></ul></li></ul></li><li>场景<ul><li>栈：后进先出 lpush lpop</li><li>队列：先进先出 lpush rpop</li><li>消息队列：lpush brpop</li></ul></li></ul></li><li>Set<ul><li>sadd&#x2F;srem&#x2F;scard&#x2F;sismember<ul><li>数据结构<ul><li><code>intset</code>当set中只包含整数型的元素时，采用intset来存储</li><li>hash</li></ul></li></ul></li></ul></li><li>Sort Set<ul><li>zadd&#x2F;zcard&#x2F;zcount&#x2F;zrange&#x2F;zrem&#x2F;zscore</li><li>数据结构<ul><li>ziplist</li><li>skiplist+hash</li></ul></li></ul></li><li>transaction<ul><li>multi&#x2F;exec&#x2F;discard&#x2F;watch</li><li>Redis Cluster不支持</li></ul></li><li>pipeline<ul><li>JedisClusterConnection不支持</li><li>LettuceClusterConnection支持</li><li>openPipeline&#x2F;closePipeline</li><li>需注意批量命令大小，防止返回值超出内存</li><li>节省网络延迟的时间，非线程安全</li></ul></li></ul><h3 id="过期时间清除key原理"><a href="#过期时间清除key原理" class="headerlink" title="过期时间清除key原理"></a>过期时间清除key原理</h3><ul><li>消极方法<ul><li>每次访问的时候删除</li></ul></li><li>积极方法<ul><li>周期性的从设置了过期时间的key中选择一部分key进行删除<ul><li>随机测试20个带有timeout信息的key</li><li>如果超过了25%的key被删除，则重复执行整个流程</li></ul></li></ul></li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul><li>持久化类型<ul><li>RDB<ul><li>快照，Redis支持将当前数据的快照存成一个数据文件的持久化机制</li><li>在第一次快照完成之后，第二次快照之前的数据会丢失</li><li>全量</li></ul></li><li>AOF<ul><li>日志，append only file，追加写入的日志文件，可识别的纯文本，它的内容就是一个redis标准命令</li><li>aof记录增删改的命令</li><li>当操作多了之后，日志文件会越来越大，可设置重写aof文件</li><li>重写aof文件，不是修改之前的aof文件，是从内存中读取数据重新生成一份aof文件</li><li>重写aof文件时，新增命令会存储在重写缓存中，然后拼接在新的aof文件中</li></ul></li></ul></li><li>开启持久化性能会有一定的损失，可同时支持两种方式，如果两种同时存在，默认以aof的数据为准。</li><li>比较<ul><li>RDB恢复速度和备份速度比AOF快</li><li>AOF数据安全性比RDB高</li></ul></li><li><code>save</code>阻塞所有客户端请求</li><li><code>bgsave</code>backgroudsave</li></ul><h3 id="过期回收策略"><a href="#过期回收策略" class="headerlink" title="过期回收策略"></a>过期回收策略</h3><ul><li><code>noeviction</code>不回收（默认）</li><li><code>allkeys-lru</code>从所有键中删除最近最少使用的键</li><li><code>allkeys-random</code>从所有键中随机删除</li><li><code>volatile-lru</code>从设置了过期时间的键中删除最近最少使用的键</li><li><code>volatile-random</code>从设置了过期时间的键中随机删除</li><li><code>volatile-ttl</code>从设置了过期时间的键中选中存活时间最短的键删除</li></ul><h3 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h3><ul><li>Redis Cluster（官方）<ul><li>客户端直连Redis，免去了proxy代理的损耗</li><li>去中心化，最大可增加1000个节点，性能随节点增加而线性扩展</li><li>使用hash slot方式 将16384个hash slot 覆盖到所有节点上</li><li>简单易上手，管理方便，可自行增加或摘除节点，移动分槽等</li><li>一致性hash思想</li><li>不支持事务，不支持数据库切换，不支持mget，单个数据库</li></ul></li><li>codis（豌豆荚）<ul><li>多了一层代理</li><li>支持透明的扩&#x2F;缩容</li><li>具有图形化管理和监控工具，运维方便</li><li>数据根据key分布到1024个slot内</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis本质上是一个Key-Value类型的内存数据库，很像Memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Ke</summary>
      
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM之类加载器</title>
    <link href="http://yoursite.com/2018/07/26/classloader/"/>
    <id>http://yoursite.com/2018/07/26/classloader/</id>
    <published>2018-07-26T04:05:40.000Z</published>
    <updated>2024-07-31T03:16:37.260Z</updated>
    
    <content type="html"><![CDATA[<p>Java类加载器是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="BootStrap-ClassLoader（启动类加载器）"><a href="#BootStrap-ClassLoader（启动类加载器）" class="headerlink" title="BootStrap ClassLoader（启动类加载器）"></a>BootStrap ClassLoader（启动类加载器）</h2><ul><li>负责加载<JAVA_HOME>&#x2F;jre&#x2F;lib目录下的jar包和Class文件。可以通过System.getProperty(“sun.boot.class.path”)获取加载的路径。</li></ul><h2 id="Extension-ClassLoader（扩展类加载器）"><a href="#Extension-ClassLoader（扩展类加载器）" class="headerlink" title="Extension ClassLoader（扩展类加载器）"></a>Extension ClassLoader（扩展类加载器）</h2><ul><li>负责加载<JAVA_HOME>&#x2F;jre&#x2F;lib&#x2F;ext或java.ext.dirs指定目录下的jar包。</li></ul><h2 id="App-ClassLoader（系统类加载器或应用类加载器）"><a href="#App-ClassLoader（系统类加载器或应用类加载器）" class="headerlink" title="App ClassLoader（系统类加载器或应用类加载器）"></a>App ClassLoader（系统类加载器或应用类加载器）</h2><ul><li>负责加载ClassPath或java.class.path目录下的jar包和Class文件。可通过ClassLoader.getSystemClassLoader()来获取。</li><li>可以通过指定java.system.class.loader来自定义系统类加载器。</li></ul><h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><ul><li>继承自ClassLoader类，重写findClass()方法</li></ul><h2 id="类加载器关系"><a href="#类加载器关系" class="headerlink" title="类加载器关系"></a>类加载器关系</h2><ul><li>类加载器直接的关系并非继承关系，而是包含关系。</li><li>启动类加载器没有父类。</li><li>扩展类加载器的父类为null。</li><li>系统类加载器的父类为sun.misc.Launcher$ExtClassLoader</li><li>自定义类加载器的父类默认为sun.misc.Launcher$AppClassLoader</li></ul><hr><h1 id="类加载模式"><a href="#类加载模式" class="headerlink" title="类加载模式"></a>类加载模式</h1><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><ul><li>如果一个类加载器接收到类加载请求，首先把这个请求委派给父类加载器去完成，每一层类加载器都是如此；只有当父类加载器无法完成这个加载请求时，子加载器才会尝试自己去加载。</li></ul><h2 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h2><ul><li>可以确保Java核心库的类型安全。</li><li>可以确保Java核心库所提供的类不会被自定义的类所代替。</li><li>不同的类加载器可以为相同的名称的类创建额外的命名空间。</li></ul><h2 id="双亲委派模型的规则"><a href="#双亲委派模型的规则" class="headerlink" title="双亲委派模型的规则"></a>双亲委派模型的规则</h2><ul><li>父类加载器加载的类不能访问自类加载器加载的类。</li><li>子类加载器加载的类可以访问父类加载器加载的类</li></ul><h2 id="线程上下文类加载器（破坏了双亲委派模型）"><a href="#线程上下文类加载器（破坏了双亲委派模型）" class="headerlink" title="线程上下文类加载器（破坏了双亲委派模型）"></a>线程上下文类加载器（破坏了双亲委派模型）</h2><ul><li>在双亲委托模型下，类加载是由下向上的，即下层的类加载器委托上层进行加载。但是对于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VydmljZV9wcm92aWRlcl9pbnRlcmZhY2U=">SPI<i class="fa fa-external-link-alt"></i></span>来说，有些接口是JAVA核心库所提供的，而Java和核心库是由启动类加载器来加载的，而这些接口的实现却来自不同的jar包（厂商提供），Java的启动类是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VydmljZV9wcm92aWRlcl9pbnRlcmZhY2U=">SPI<i class="fa fa-external-link-alt"></i></span>的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">try&#123;</span><br><span class="line">Thread.currentThread().setContextClassLoader(appClassLoader);</span><br><span class="line">//具体业务逻辑实现</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="类加载器加载过程"><a href="#类加载器加载过程" class="headerlink" title="类加载器加载过程"></a>类加载器加载过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>查找并加载类的二进制数据，并放入内存中。</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>验证：确保被加载的类的正确性。（类文件结构检查；语义检查；字节码检查；二进制兼容性的验证）</li><li>准备：为类的静态变量分配内存，并将初始化默认值。</li><li>解析：把类中的符号引用转化为直接引用。<ul><li>符号引用：在编译时，Java类并不知道所引用的类的实际地址，因此只能使用符号来代替。</li><li>直接引用：直接执向目标的指针。</li></ul></li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>为类的静态变量赋予正确的初始值。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul><li>JVM自带的类加载器加载的类，在JVM的生命周期中，始终不会被卸载。</li><li>用户自定义的类加载器所加载的类是可以被卸载的。</li></ul><hr><h1 id="类加载器时机"><a href="#类加载器时机" class="headerlink" title="类加载器时机"></a>类加载器时机</h1><ul><li>JVM虚拟机必须在每个类或接口被Java程序首次主动使用时才初始化。</li><li>主动使用<ul><li>通过new创建一个类的实例</li><li>反射Class.forName()</li><li>访问类的静态变量或静态方法</li><li>为一个类的静态变量赋值</li><li>初始化一个类时，父类未初始化时，先初始化父类</li><li>虚拟机启动时，定义了main方法的类</li></ul></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java类加载器是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。&lt;/p&gt;
&lt;h1 id=&quot;类加载器&quot;&gt;&lt;a href=&quot;#类加载器&quot; class=&quot;headerlink&quot; title=&quot;类</summary>
      
    
    
    
    <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
    <category term="类加载器" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud</title>
    <link href="http://yoursite.com/2018/04/10/springcloud/"/>
    <id>http://yoursite.com/2018/04/10/springcloud/</id>
    <published>2018-04-10T12:58:54.000Z</published>
    <updated>2024-07-31T03:16:37.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><h4 id="PropertySource-配置源"><a href="#PropertySource-配置源" class="headerlink" title="PropertySource 配置源"></a><code>PropertySource</code> 配置源</h4><ul><li><p><code>MapPropertySource</code></p><ul><li><code>PropertiesPropertySource</code></li></ul></li><li><p><code>CompositePropertySource</code> 组合</p></li><li><p><code>SystemEnvironmentPropertySource</code> 环境变量</p></li><li><p><code>PropertySourceLocator</code> Spring Cloud 客户端配置定位扩展，</p><ul><li><p>实现该接口</p></li><li><p>暴露该实现作为一个Spring Bean</p></li><li><p>定义并且配置 &#x2F;META-INF&#x2F;spring.factories:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.cloud.bootstrap.BootstrapConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.gupao.springcloudconfigclient.SpringCloudConfigClientApplication.MyPropertySourceLocator</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="EnableConfigServer"><a href="#EnableConfigServer" class="headerlink" title="@EnableConfigServer"></a><code>@EnableConfigServer</code></h4><ul><li><p><code>@EnableConfigServer</code> 启动配置中心，默认<code>DefaultRepositoryConfiguration</code>（Git实现）</p></li><li><p>自定义实现所需<code>EnvironmentRepository</code>  核心接口，</p><ul><li>注入一个<code>EnvironmentRepository</code>  即可</li></ul></li></ul><h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h4><p>端点URI：&#x2F;health</p><p>实现类：<code>HealthEndpoint</code></p><p>健康指示器：<code>HealthIndicator</code>，</p><p><code>HealthEndpoint</code>：<code>HealthIndicator</code> ，一对多</p><p>自定义实现<code>HealthIndicator</code></p><ul><li><p>实现<code>AbstractHealthIndicator</code></p></li><li><p>暴露实现为<code>Bean</code></p></li><li><p>关闭安全控制</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.security.enabled</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Spring-Cloud-Netflix-Eureka"><a href="#Spring-Cloud-Netflix-Eureka" class="headerlink" title="Spring Cloud Netflix Eureka"></a>Spring Cloud Netflix Eureka</h3><p><code>@EnableDiscoveryClient</code></p><p><code>@EnableEurekaServer</code></p><h3 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h3><h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><h3 id="Spring-Cloud-Netflix-Zuul"><a href="#Spring-Cloud-Netflix-Zuul" class="headerlink" title="Spring Cloud Netflix Zuul"></a>Spring Cloud Netflix Zuul</h3><p><code>@EnableZuulServer</code></p><p><code>@EnableZuulProxy</code></p><p>基于Servlet和Filter实现</p><ul><li><code>ZuulHandlerMapping</code></li><li><code>ZuulController</code></li><li><code>ZuulServlet</code></li><li><code>ZuulRunner</code></li><li><code>FilterProcessor</code> -&gt; <code>FilterLoader</code> -&gt; <code>List&lt;ZuulFilter&gt;</code></li><li>Filter执行顺序<ul><li>pre，权限校验、限流、选取路由机器<ul><li><code>ServletDetectionFilter</code>检测请求是用DispatcherServlet还是 ZuulServlet</li><li><code>Servlet30WrapperFilter</code>在Servlet 3.0 下，包装 requests</li><li><code>FormBodyWrapperFilter</code>解析表单数据</li><li><code>DebugFilter</code>设置请求过程是否开启debug</li><li><code>PreDecorationFilter</code>根据uri决定调用哪一个route过滤器</li></ul></li><li>route，向选举出来的server发送请求<ul><li><code>RibbonRoutingFilter</code>如果写配置的时候用ServiceId则用这个route过滤器，该过滤器可以用Ribbon 做负载均衡，用hystrix做熔断</li><li><code>SimpleHostRoutingFilter</code>如果写配置的时候用url则用这个route过滤</li><li><code>SendForwardFilter</code>用RequestDispatcher请求转发</li></ul></li><li>post，收集统计数据<ul><li><code>SendResponseFilter</code>用HttpServletResponse响应</li><li><code>SendErrorFilter</code> 任意阶段出错</li></ul></li></ul></li></ul><h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><p>基于webflux的实现</p><ul><li><p><code>DispatcherHandler</code></p></li><li><p><code>RoutePredicateHandlerMapping</code></p></li><li><p><code>FilteringWebHandler</code></p></li><li><p><code>DefaultGatewayFilterChain</code></p><ul><li><code>AdaptCachedBodyGlobalFilter</code></li><li><code>NettyWriteResponseFilter</code></li><li><code>ForwardPathFilter</code></li><li><code>GatewayMetricsFilter</code></li><li><code>RouteToRequestUrlFilter</code></li><li><code>LoadBalancerClientFilter</code></li><li><code>WebsocketRoutingFilter</code></li><li><code>NettyRoutingFilter</code></li><li><code>ForwardRoutingFilter</code></li></ul></li></ul><h3 id="Spring-Cloud-Netflix-Hystrix"><a href="#Spring-Cloud-Netflix-Hystrix" class="headerlink" title="Spring Cloud Netflix Hystrix"></a>Spring Cloud Netflix Hystrix</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li><p>@EnableHystrix</p></li><li><p>@EnableCircuitBreaker</p></li><li><p>@HystrixCommand</p></li></ul><p>基于AOP的实现</p><p>容器启动注入一个HystrixCommandAspect的Bean</p><h3 id="Spring-Cloud-Netflix-Ribbon"><a href="#Spring-Cloud-Netflix-Ribbon" class="headerlink" title="Spring Cloud Netflix Ribbon"></a>Spring Cloud Netflix Ribbon</h3><p>@LoadBalance</p><h4 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h4><ul><li>ILoadBalancer<ul><li>BaseLoadBalancer</li><li>DynamicServerListLoadBalancer</li><li>ZoneAwareLoadBalancer</li><li>NoOpLoadBalancer</li></ul></li></ul><h4 id="负载均衡规则"><a href="#负载均衡规则" class="headerlink" title="负载均衡规则"></a>负载均衡规则</h4><ul><li>IRule<ul><li>RandomRule：随机规则</li><li>BestAvailableRule：最可用规则</li><li>RoundRobinRule：轮询规则</li><li>RetryRule：重试实现</li></ul></li></ul><h4 id="负载均衡客户端"><a href="#负载均衡客户端" class="headerlink" title="负载均衡客户端"></a>负载均衡客户端</h4><p><code>ServiceInstanceChooser</code></p><p><code>LoadBalancerClient</code></p><h4 id="负载均衡上下文"><a href="#负载均衡上下文" class="headerlink" title="负载均衡上下文"></a>负载均衡上下文</h4><p><code>LoadBalancerContext</code></p><h3 id="Spring-Cloud-Netflix-Feign"><a href="#Spring-Cloud-Netflix-Feign" class="headerlink" title="Spring Cloud Netflix Feign"></a>Spring Cloud Netflix Feign</h3><p>@EnableFeignClients</p><p>@FeignClient</p><ol><li>容器启动时，注入包含@FeignClient注解的所有接口</li><li>接口通用实现类FeignClientFactoryBean</li><li>在FeignClientFactoryBean中的getObject方法中<ol><li>设置Http请求相关参数，编码、解码、获取HttpClient类型</li><li>通过URL判断请求类型，如果是LoadBalancerFeignClient，则通过Ribbon进行负载，通过对应的负载算法获取HttpClient</li><li>通过JDK动态代理为目标接口生成一个动态代理类，代理类会生成一个方法拦截器SynchronousMethodHandler</li></ol></li><li>当发起方法调用时，SynchronousMethodHandler根据请求参数，获取RestTemplate，然后进行调用<ol><li>通过Ribbon进行负载</li></ol></li></ol><h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><p><code>@Output</code></p><p><code>@Input</code></p><p><code>MessageChannel</code></p><h4 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h4><p><code>Binder</code></p><h3 id="Spring-Cloud-Seluth"><a href="#Spring-Cloud-Seluth" class="headerlink" title="Spring Cloud Seluth"></a>Spring Cloud Seluth</h3><h4 id="追踪类型"><a href="#追踪类型" class="headerlink" title="追踪类型"></a>追踪类型</h4><ul><li><p>@Scheduled</p><ul><li>TraceSchedulingAspect处理</li></ul></li><li><p>Messaging</p><ul><li>基于spring messaging的ChannelInterceptor</li></ul></li><li><p>Hystrix</p><ul><li>基于HystrixPlugins添加trace相关的plugin，自定义了一个HystrixConcurrencyStrategy的实现SleuthHystrixConcurrencyStrategy</li></ul></li><li><p>Feign</p><ul><li>TraceFeignAspect</li><li>TracingFeignClient</li><li>TraceLoadBalancerFeignClient</li></ul></li><li><p>Async</p><ul><li><p>基于AOP的实现TraceAsyncAspect</p><p>@Async注解和ThreadPoolTaskExecutor下面的类</p></li></ul></li><li><p>Http Web</p><ul><li>TracingClientHttpRequestInterceptor</li></ul></li><li><p>Zuul</p><ul><li>Zuul的Filter机制，实现了TracePostZuulFilter</li></ul></li></ul><h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><h3 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a>Spring Security OAuth2</h3><h3 id="Spring-Session-Redis"><a href="#Spring-Session-Redis" class="headerlink" title="Spring Session + Redis"></a>Spring Session + Redis</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Spring-Cloud-Config&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Config&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Config&quot;&gt;&lt;/a&gt;Spring Cloud Config&lt;/h3&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
    <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringWeb</title>
    <link href="http://yoursite.com/2018/04/08/springweb/"/>
    <id>http://yoursite.com/2018/04/08/springweb/</id>
    <published>2018-04-08T12:59:40.000Z</published>
    <updated>2024-07-31T03:16:37.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><ul><li>优点<ul><li>简化依赖管理</li><li>自动化配置</li><li>嵌入式容器</li><li>生产级监控端点</li></ul></li></ul><h4 id="SpringBoot2-0特性"><a href="#SpringBoot2-0特性" class="headerlink" title="SpringBoot2.0特性"></a>SpringBoot2.0特性</h4><ul><li>支持Java9</li><li>基于Spring5构建</li><li>各种jar版本升级</li><li>支持Http&#x2F;2</li><li>默认数据库连接池从Tomcat改为HikariCP</li></ul><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><ul><li>用户发起请求到前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping查找Handler（注解或XML）</li><li>DispatcherServlet通过HandlerAdapter去执行Handler</li><li>HandlerAdapter经过适配调用具体的处理器（Controller）</li><li>Controller执行完成返回ModelAndView</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet根据View进行渲染视图</li><li>DispatcherServlet响应用户</li></ul><h3 id="Struts-Struts2"><a href="#Struts-Struts2" class="headerlink" title="Struts&#x2F;Struts2"></a>Struts&#x2F;Struts2</h3><ul><li>Struts1以ActionServlet作为核心控制器，Struts2以FilterDispatcher作为核心控制器；</li><li>Struts1的action需要继承action类，Struts2的action不用继承任何类；</li><li>Struts1是单例模式，对同一路径的所有请求共享一个实例，Struts2对同一路径的每个请求分别使用一个独立的Action对象实例，所以Struts2是线程安全的。</li><li>Struts1使用formbean封装请求参数，Struts2中直接使用action的属性封装请求参数；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;优点&lt;ul&gt;
&lt;li&gt;简化依赖管理&lt;/li&gt;
&lt;li&gt;自动化配置</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
    <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://yoursite.com/2018/04/06/springboot/"/>
    <id>http://yoursite.com/2018/04/06/springboot/</id>
    <published>2018-04-06T12:58:02.000Z</published>
    <updated>2024-07-31T03:16:37.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>传统Web MVC架构</li><li>前后端分离架构</li><li>微服务架构</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>可创建独立的Spring应用程序</li><li>提供嵌入式Web Server（无需部署war包）</li><li>无需任何代码生成技术也无任何XML配置</li><li>自动化配置</li><li>提供一系列生产级特性<ul><li>端点(<code>endpoints.enable=true</code>开启端点)<ul><li><code>autoconfig</code>获取自动配置信息</li><li><code>beans</code>获取Spring Bean基本信息</li><li><code>configprops</code>获取配置项信息</li><li><code>dump</code>获取当前线程基本信息</li><li><code>env</code>获取环境变量信息</li><li><code>health</code>获取健康检查信息<ul><li><code>enpoints.health.enable = true</code> 开启健康检查</li><li><code>enpoints.health.sensitive = true</code> 获取敏感性，默认false，如果为true，则不返回敏感字段</li><li><code>enpoints.health.time-to-live = 500</code> 设置健康检查的缓存时间，单位ms，默认1000</li><li>自定义健康检查器<ul><li>实现org.springframework.boot.actuate.health.HealthIndicator接口</li></ul></li></ul></li><li><code>info</code>获取应用基本信息<ul><li><code>enpoints.info.enable = true</code> 开启应用信息</li><li><code>info.app.name = @project.name@</code> 获取pom.xml中的name</li><li><code>info.app.description = @project.description@</code> 获取pom.xml中的description</li><li><code>info.app.version = @project.version@</code> 获取pom.xml中的version</li><li>可通过git-commit-id-plugin插件获取Git信息<ul><li><code>info.git.branch = @git.branch@</code> 获取Git版本信息</li><li><code>info.git.commit.id = @git.commit.id@</code> 获取Git提交ID</li><li><code>info.git.commit.time = @git.commit.time@</code> 获取Git提交时间</li></ul></li></ul></li><li><code>metrics</code>获取性能指标信息<ul><li><code>enpoints.metrics.enable = true</code> 开启性能指标</li><li><code>enpoints.metrics.id = performance</code> 自定义ID</li><li><code>enpoints.metrics.path = /enpoints/metrices</code> 自定义请求路径</li></ul></li><li><code>mappings</code>获取请求映射信息</li><li><code>trace</code>获取请求调用信息</li></ul></li><li>跨域（Spring4.2之后支持）<ul><li>方法一<ul><li><code>endpoints.cors.allowed-origins = http://www.baidu.com</code> 配置跨域域名</li><li><code>endpoints.cors.allowed-methods = GET,POST,PUT,DELETE</code> 配置跨域支持方法</li></ul></li><li>方法二<ul><li>@CrossOrigin注解</li></ul></li><li>方法三<ul><li>继承org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter的addCorsMappings方法</li></ul></li></ul></li><li>外部化配置，按顺序如下<ul><li>Java命令行参数</li><li>JNDI属性</li><li>Java系统属性</li><li>操作系统环境变量</li><li>Jar包外的application.properties配置</li><li>Jar包内的application.properties配置</li><li>@PropertySource注解</li><li>SpringApplication.setDefaultProperties默认值</li></ul></li><li>远程监控<ul><li>ssh方式<ul><li>引入spring-boot-starter-remote-shell</li><li>配置<ul><li>shell.ssh.port &#x3D; 2000</li><li>shell.auth.simple.user.name &#x3D; admin</li><li>shell.auth.simple.user.password &#x3D; 123456</li></ul></li><li>ssh -p 2000 <span class="exturl" data-url="bWFpbHRvOiYjeDYxOyYjMTAwOyYjMTA5OyYjeDY5OyYjeDZlOyYjNjQ7JiM0OTsmI3gzMjsmI3gzNzsmIzQ2OyYjNDg7JiN4MmU7JiN4MzA7JiN4MmU7JiN4MzE7">&#x61;&#100;&#109;&#x69;&#x6e;&#64;&#49;&#x32;&#x37;&#46;&#48;&#x2e;&#x30;&#x2e;&#x31;<i class="fa fa-external-link-alt"></i></span></li></ul></li><li>telnet方式<ul><li>引入crsh.shell.telnet</li></ul></li></ul></li></ul></li><li>提供开箱即用的Spring插件</li></ul><p>@EnableWebMvc&#96;</p><p><code>@EnableAsync</code></p><p><code>@EnableAspectJAutoProxy</code></p><ul><li><p>处理类 <code>ConfigurationClassParser</code></p></li><li><p>扫描类 <code>ClassPathBeanDefinitionScanner</code></p><ul><li><code>ClassPathScanningCandidateComponentProvider</code></li></ul></li><li><p>注解驱动上下文 <code>AnnotationConfigApplicationContext</code></p></li></ul><p>Spring 事件</p><ul><li><code>ContextRefreshedEvent</code><ul><li><code>ApplicationContextEvent</code></li><li><code>ApplicationEvent</code></li></ul></li><li><code>ContextClosedEvent</code></li></ul><p>自定义事件</p><ul><li><code>PayloadApplicationEvent</code></li></ul><p>Spring 事件的类型 <code>ApplicationEvent</code></p><p>Spring 事件监听器 <code>ApplicationListener</code></p><p>Spring 事件广播器 <code>ApplicationEventMulticaster</code></p><ul><li>实现类：<code>SimpleApplicationEventMulticaster</code></li></ul><p>Spring事件执行顺序</p><ol><li>ApplicationStartingEvent（1）</li><li>ApplicationEnvironmentPreparedEvent（2）</li><li>ApplicationPreparedEvent（3）</li><li>ContextRefreshedEvent</li><li>ServletWebServerInitializedEvent</li><li>ApplicationStartedEvent（4）</li><li>ApplicationReadyEvent（5）</li><li>ContextClosedEvent</li><li>ApplicationFailedEvent (特殊情况)（6）</li></ol><p>优化</p><ul><li>移除JspServlet（Jsp页面编译）</li><li>移除DefaultServlet（静态资源解析）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;传统Web MVC架构&lt;/li&gt;
&lt;li&gt;前后端分离架构&lt;/li&gt;
&lt;li&gt;微服务架构&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://yoursite.com/2018/03/30/spring/"/>
    <id>http://yoursite.com/2018/03/30/spring/</id>
    <published>2018-03-30T12:57:06.000Z</published>
    <updated>2024-07-31T03:16:37.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="Spring-Bean作用域"><a href="#Spring-Bean作用域" class="headerlink" title="Spring Bean作用域"></a>Spring Bean作用域</h3><ul><li><p><code>singleton</code></p><p>单例注册表的单例模式实现，每个<code>Bean</code>在SpringIOC容器中只存在一个实例，会缓存<code>Bean</code>实例。</p><p>默认启动容器就创建了对象，如果设置<code>lazy-init=true</code>，则在调用<code>getBean</code>方法的时候创建。</p></li><li><p><code>prototype</code></p><p>每次<code>getBean</code>的时候都返回一个全新的<code>Bean</code>，不缓存<code>Bean</code>实例</p></li><li><p><code>request</code></p><p>每个<code>Http</code>请求创建一个<code>Bean</code>实例</p></li><li><p><code>session</code></p><p>每个<code>Session</code>创建一个<code>Bean</code>实例</p></li><li><p>自定义作用域</p><ol><li>实现<code>org.springframework.beans.factory.config.Scope</code>接口</li><li>向Spring容器注册新的作用域<ul><li><code>ConfigurableBeanFactory.registerScope(String scopeName, Scope scope)</code></li></ul></li></ol></li></ul><h3 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h3><ol><li><strong>BeanFactoryPostProcessor</strong>#postProcessBeanFactory</li><li><strong>InstantiationAwareBeanPostProcessor</strong>#postProcessBeforeInstantiation</li><li>执行Bean的构造函数</li><li><strong>InstantiationAwareBeanPostProcessor</strong>#postProcessAfterInstantiation</li><li><strong>InstantiationAwareBeanPostProcessor</strong>#postProcessPropertyValues</li><li>Bean属性注入</li><li>org.springframework.beans.factory.<strong>BeanNameAware</strong>#setBeanName</li><li>org.springframework.beans.factory.<strong>BeanClassLoaderAware</strong>#setBeanClassLoader</li><li>org.springframework.beans.factory.<strong>BeanFactoryAware</strong>#setBeanFactory</li><li>org.springframework.beans.factory.config.<strong>BeanPostProcessor</strong>#postProcessBeforeInitialization<ol><li><strong>ApplicationContextAwareProcessor</strong>#postProcessBeforeInitialization<ol><li>org.springframework.context.<strong>EnvironmentAware</strong>#setEnvironment</li><li>org.springframework.context.<strong>EmbeddedValueResolverAware</strong>#setEmbeddedValueResolver</li><li>org.springframework.context.<strong>ResourceLoaderAware</strong>#setResourceLoader</li><li>org.springframework.context.<strong>ApplicationEventPublisherAware</strong>#setApplicationEventPublisher</li><li>org.springframework.context.<strong>MessageSourceAware</strong>#setMessageSource</li><li>org.springframework.context.<strong>ApplicationContextAware</strong>#setApplicationContext</li></ol></li><li>ConfigurationClassPostProcessor.<strong>ImportAwareBeanPostProcessor</strong>#postProcessBeforeInitialization<ol><li>org.springframework.context.annotation.<strong>ImportAware</strong>#setImportMetadata</li></ol></li></ol></li><li>org.springframework.beans.factory.<strong>InitializingBean</strong>#afterPropertiesSet</li><li>调用bean的init-method方法</li><li>org.springframework.beans.factory.config.<strong>BeanPostProcessor</strong>#postProcessAfterInitialization</li><li>初始化完成</li><li>调用DisposableBean的destory方法</li><li>调用bean的destory-method方法</li></ol><h3 id="Spring-Bean注入方式"><a href="#Spring-Bean注入方式" class="headerlink" title="Spring Bean注入方式"></a>Spring Bean注入方式</h3><ul><li><p>注解注入</p></li><li><p>构造方法注入</p></li><li><p>setter注入</p></li></ul><h3 id="BeanFactory和FactoryBean、ApplicationContext-的区别"><a href="#BeanFactory和FactoryBean、ApplicationContext-的区别" class="headerlink" title="BeanFactory和FactoryBean、ApplicationContext 的区别"></a>BeanFactory和FactoryBean、ApplicationContext 的区别</h3><ul><li><p><code>BeanFactory</code></p><p>IOC容器的最基本形式；对象工厂；获取spring中注入的bean都需要继承此接口；<code>XmlWebApplicationContext</code>实现了此接口</p></li><li><p><code>FactoryBean</code></p><p>IOC容器中的一个Bean</p><p>框架中的实现类</p><ul><li><p><code>Mybatis</code></p><ul><li><code>SqlSessionFactoryBean</code></li><li><code>MapperFactoryBean</code></li></ul></li><li><p><code>Dubbo</code></p><ul><li><code>ReferenceBean</code></li></ul></li><li><p><code>Spring Cloud OpenFeign</code></p><ul><li><code>FeignClientFactoryBean</code></li></ul></li></ul></li><li><p><code>ApplicationContext</code></p><p><code>ApplicationContext</code>接口对<code>BeanFactory</code>进行了扩展</p><ul><li>支持信息源，可以实现国际化（实现 <code>MessageSource</code> 接口）</li><li>访问资源(实现 <code>ResourcePatternResolver</code> 接口)</li><li>支持应用事件(实现 <code>ApplicationEventPublisher</code> 接口)</li></ul></li></ul><h3 id="Autowired和-Resource的区别"><a href="#Autowired和-Resource的区别" class="headerlink" title="@Autowired和@Resource的区别"></a>@Autowired和@Resource的区别</h3><ul><li><p><code>@Autowired</code>和<code>@Inject</code></p><p>默认按照类型装配，如果想按照名称来装配，则需要结合<code>@Qualifier</code>才能使用名称</p></li><li><p><code>@Resource</code></p><p>默认按照名称装配，如果找不到与名称匹配的bean才会按照类型来装配；</p></li></ul><h3 id="Bean循环注入"><a href="#Bean循环注入" class="headerlink" title="Bean循环注入"></a>Bean循环注入</h3><h4 id="出现循环注入的方式"><a href="#出现循环注入的方式" class="headerlink" title="出现循环注入的方式"></a>出现循环注入的方式</h4><ul><li>原型模式（prototype）的setter方式注入</li><li>构造函数参数循环依赖</li></ul><h4 id="解决循环注入的方式"><a href="#解决循环注入的方式" class="headerlink" title="解决循环注入的方式"></a>解决循环注入的方式</h4><ul><li>setter单例模式</li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>基于接口的动态代理</p><h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>基于类的动态代理，采用的继承的方式，覆盖父类方法，所以不能对final类生成代理</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><ul><li>连接点（Joinpoint）被拦截到的点，具体方法</li><li>切点（Pointcut）指定对哪些Joinpoint进行拦截，可以同时指定多个函数，一般使用正则表达式</li><li>通知（Advice）<ul><li>前置通知（Before）</li><li>后置通知（AfterReturning）</li><li>异常通知（AfterRThrowing）</li><li>最终通知（After）</li><li>环绕通知（Around）</li></ul></li><li>引介（Introduction）</li><li>织入（Weaving）<ul><li>编译期织入（AspectJ采用的方式）需要特殊的Java编译期（例如AspectJ的ajc）</li><li>装载期织入（AspectJ采用的方式）要求使用特殊的类加载器，在装载类的时候对类进行增强</li><li>运行时织入（Spring采用的方式）在运行时为目标类生成代理实现增强</li></ul></li><li>切面（Aspect）切入点和通知的结合</li></ul><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="传播机制"><a href="#传播机制" class="headerlink" title="传播机制"></a>传播机制</h4><ul><li><p>propagation_required</p><p>（默认）支持当前事务，如果没有就新建一个</p></li><li><p>propagation_supports</p><p>支持当前事务，如果当前没有事务，就以非事务执行；</p></li><li><p>propagation_mandatory</p><p>支持当前事务，如果当前没有事务，就抛出异常；</p></li><li><p>propagation_not_supported</p><p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起；</p></li><li><p>propagation_never</p><p>以非事务方式执行，如果当前存在事务，则抛出异常；</p></li><li><p>propagation_requires_new</p><p>新建事务，如果当前存在，把当前事务挂起；外层事务失败回滚，不能回滚内层事务；内层事务失败抛出异常，外层事务可以不处理回滚操作；</p></li><li><p>propagation_nested</p><p>如果一个活动的事务存在，则运行在一个嵌套的事务中；如果没有活动事务，则按required执行；内部事务回滚不会对外部事务造成影响；</p></li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul><li><p>读未提交（ISOLATION_READ_UNCOMMITTED）</p><p>这种隔离级别会产生脏读， 不可重复读和幻读 </p></li><li><p>读已提交（ISOLATION_READ_COMMITTED）</p><p>这种隔离级别会产生不可重复读和幻读</p></li><li><p>可重复读（ISOLATION_REPEATABLE_READ）</p><p>这种隔离级别会产生幻读</p></li><li><p>串行化读（ISOLATION_SERIALIZABLE）</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>单例模式（IOC）</li><li>代理模式（AOP）</li><li>工厂方法模式<ul><li>工厂方法模式</li></ul></li><li>简单工厂模式<ul><li>BeanFactory</li></ul></li><li>策略模式<ul><li>DefaultAopProxyFactory<ul><li>JdkDynamicAopProxy</li><li>ObjenesisCglibAopProxy</li></ul></li></ul></li><li>模板方法模式<ul><li>JdbcTemplate</li><li>RestTemplate</li></ul></li></ul><h2 id="Spring-5-新特性"><a href="#Spring-5-新特性" class="headerlink" title="Spring 5 新特性"></a>Spring 5 新特性</h2><ul><li><p>支持Java9，Spring5框架基于Java8开发</p></li><li><p>支持响应式编程</p></li><li><p>函数式Web框架</p></li><li><p>支持Kotlin</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC&quot;&gt;&lt;/a&gt;IOC&lt;/h2&gt;&lt;h3 id=&quot;Spring-Bean作用域&quot;&gt;&lt;a href=&quot;#Spring-Bean作用域&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ORM</title>
    <link href="http://yoursite.com/2018/03/23/orm/"/>
    <id>http://yoursite.com/2018/03/23/orm/</id>
    <published>2018-03-23T12:55:56.000Z</published>
    <updated>2024-07-31T03:16:37.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><ul><li><p>通过<code>SqlSessionFactoryBuilder</code>解析XML文件，得到<code>SqlSessionFactory</code></p><ul><li><p><code>XMLConfigBuilder</code></p><p>解析mybatis中configLocation属性中的全局xml文件</p></li><li><p><code>XMLMapperBuilder</code></p><p>遍历mybatis中mapperLocations属性中的xml文件中的每个节点的Builder</p></li><li><p><code>XMLStatementBuilder</code></p><p>解析xml文件中的各个节点，如select&#x2F;insert&#x2F;update&#x2F;delete节点，遍历产生的数据会被放到<code>Configuration</code>的mappedStatements中</p></li><li><p><code>XMLScriptBuilder</code></p><p>解析xml中各个节点sql部分的Builder</p></li></ul></li><li><p>通过<code>SqlSessionFactory</code>获取SqlSession</p></li><li><p>通过<code>Executor</code>执行select&#x2F;insert&#x2F;update&#x2F;delete方法</p></li><li><p>关闭<code>SqlSession</code></p></li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><ul><li>作用域<ul><li><code>Session</code>（默认）同一个session中缓存，不同session中会出现脏读</li><li><code>Statement</code> 同一个statement中缓存</li></ul></li></ul><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>实现了SqlSession之间的缓存数据共享，同时粒度更细，可以到namespace，多表查询可能会出现脏读</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>统计sql执行时间</li><li>读写分离，sql执行前检查sql是不是查询方法，根据这个控制访问的数据源</li></ul><h4 id="拦截方法"><a href="#拦截方法" class="headerlink" title="拦截方法"></a>拦截方法</h4><ul><li><code>Executor</code><ul><li>update</li><li>query</li><li>flushStatements</li><li>commit</li><li>rollback</li><li>getTrahsaction</li><li>close</li><li>isClosed</li></ul></li><li><code>ParameterHandler</code><ul><li>getParameterObject</li><li>setParameters</li></ul></li><li><code>ResultSetHandler</code><ul><li>handlerResultSets</li><li>HandlerOutputParameters</li></ul></li><li><code>StatementHandler</code><ul><li>prepare</li><li>parameterize</li><li>batch</li><li>update</li><li>query</li></ul></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>工厂方法模式<ul><li><code>SqlSessionFactory</code></li><li><code>MapperProxyFactory</code></li></ul></li><li>代理模式<ul><li><code>MapperProxy</code></li></ul></li><li>建造者模式<ul><li><code>SqlSessionFactoryBuilder</code><ul><li><code>XMLConfigBuilder</code></li><li><code>XMLMapperBuilder</code></li><li><code>XMLStatementBuilder</code></li></ul></li></ul></li><li>模板方法模式<ul><li><code>BaseExecutor</code><ul><li><code>SimpleExecutor</code></li><li><code>ResumeExecutor</code></li><li><code>BatchExecutor</code></li></ul></li></ul></li><li>适配器模式<ul><li>logging包统一了各大日志框架的接口，比如LogFactory</li></ul></li><li>责任链模式<ul><li>plugins插件处理<ul><li><code>Interceptor</code></li><li><code>InterceptorChain</code></li></ul></li></ul></li></ul><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><h3 id="加载过程-1"><a href="#加载过程-1" class="headerlink" title="加载过程"></a>加载过程</h3><ul><li>通过<code>org.hibernate.cfg.Configuration</code>读取并解析配置文件</li><li>通过Configuration创建SessionFactory</li><li>打开Session</li><li>创建事务Transaction</li><li>持久化操作</li><li>提交事务</li><li>关闭session</li><li>关闭SessionFactory</li></ul><h3 id="对象状态"><a href="#对象状态" class="headerlink" title="对象状态"></a>对象状态</h3><ul><li>临时状态（new出来的对象）</li><li>持久状态（数据库存在对应的记录）</li><li>游离状态（session关闭后，持久化对象变成游离对象）</li></ul><h3 id="Session方法"><a href="#Session方法" class="headerlink" title="Session方法"></a>Session方法</h3><ul><li><code>session.lock()</code>把没有更改过的托管状态的对象转换成持久态</li><li><code>session.merge()</code>将新的状态合并到已有的持久化对象上或创建新的持久化对象</li><li><code>session.saveOrUpdate()</code>如果对象不存在，瞬时状态变成持久态；如果存在，则游离状态转换成持久态</li></ul><h2 id="Mybatis和Hibernate区别"><a href="#Mybatis和Hibernate区别" class="headerlink" title="Mybatis和Hibernate区别"></a>Mybatis和Hibernate区别</h2><ul><li>Mybatis<ul><li>解耦（解除sql与程序代码的耦合）</li><li>提供映射标签，支持对象与数据库的字段关系映射</li><li>提供xml标签，支持编写动态sql</li></ul></li><li>Hibernate<ul><li>Dao层开发简单</li><li>数据库移植性好</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h2&gt;&lt;h3 id=&quot;加载过程&quot;&gt;&lt;a href=&quot;#加载过程&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="ORM" scheme="http://yoursite.com/tags/ORM/"/>
    
    <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
    <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="http://yoursite.com/2018/01/23/tomcat/"/>
    <id>http://yoursite.com/2018/01/23/tomcat/</id>
    <published>2018-01-23T13:01:03.000Z</published>
    <updated>2024-07-31T03:16:37.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat-架构"><a href="#Tomcat-架构" class="headerlink" title="Tomcat 架构"></a>Tomcat 架构</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="conf-目录"><a href="#conf-目录" class="headerlink" title="conf 目录"></a>conf 目录</h3><p><code>catalina.policy</code> :  Tomcat 安全策略文件，控制 JVM 相关权限，具体可以参考<code>java.security.Permission</code></p><p><code>catalina.properties</code> : Tomcat Catalina 行为控制配置文件，比如 Common ClassLoader</p><p><code>logging.properties</code>  : Tomcat 日志配置文件，JDK Logging</p><p><code>server.xml</code>  :  Tomcat Server 配置文件</p><ul><li><code>GlobalNamingResources</code> : 全局 JNDI 资源</li></ul><p><code>context.xml</code> : 全局 Context 配置文件</p><p><code>tomcat-users.xml</code> : Tomcat 角色配置文件，（Realm 文件实现方式）、</p><p><code>web.xml</code> : Servlet 标准的 web.xml 部署文件，Tomcat 默认实现部分配置入内：</p><ul><li><code>org.apache.catalina.servlets.DefaultServlet</code></li><li><code>org.apache.jasper.servlet.JspServlet</code></li></ul><h3 id="lib-目录"><a href="#lib-目录" class="headerlink" title="lib 目录"></a>lib 目录</h3><p>Tomcat 存放公用类库</p><p><code>ecj-*.jar</code>  : Eclipse Java 编译器</p><p><code>jasper.jar</code> : JSP 编译器</p><h3 id="logs-目录"><a href="#logs-目录" class="headerlink" title="logs 目录"></a>logs 目录</h3><p><code>localhost.$&#123;date&#125;.log</code> :  当 Tomcat 应用起不来的时候，多看该文件，比如：类冲突</p><ul><li><code>NoClassDefFoundError</code></li><li><code>ClassNotFoundException</code></li></ul><p><code>catalina.$&#123;date&#125;.log</code> : 控制台输出，<code>System.out</code> 外置</p><h2 id="webapps-目录"><a href="#webapps-目录" class="headerlink" title="webapps 目录"></a>webapps 目录</h2><p>简化 web 应用部署的方式</p><h2 id="部署-Web-应用"><a href="#部署-Web-应用" class="headerlink" title="部署 Web 应用"></a>部署 Web 应用</h2><h3 id="方法一：放置在-webapps-目录"><a href="#方法一：放置在-webapps-目录" class="headerlink" title="方法一：放置在 webapps 目录"></a>方法一：放置在 <code>webapps </code>目录</h3><p>直接拖过去</p><h3 id="方法二：-修改-confi-server-xml"><a href="#方法二：-修改-confi-server-xml" class="headerlink" title="方法二： 修改 confi/server.xml"></a>方法二： 修改 <code>confi/server.xml</code></h3><p>添加<code>Context</code> 元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;$&#123;webAppAbsolutePath&#125;&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;$&#123;webAppAbsolutePath&#125;&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/tomcat&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>熟悉配置元素可以参考<code>org.apache.catalina.core.StandardContext</code> setter 方法</p><p><code>Container</code></p><ul><li><code>Context</code></li></ul><p>该方式不支持动态部署，建议考虑在生产环境使用。</p><h3 id="方法三：独立-context-xml-配置文件"><a href="#方法三：独立-context-xml-配置文件" class="headerlink" title="方法三：独立 context xml 配置文件"></a>方法三：独立 <code>context</code> xml 配置文件</h3><p>首先注意 <code>conf\Catalina\localhost</code></p><p>独立 context XML 配置文件路径：<code>$&#123;TOMCAT_HOME&#125;/conf/Catalina/localhost</code> + <code>$&#123;ContextPath&#125;</code> .xml</p><p>注意：该方式可以实现热部署，因此建议在开发环境使用。</p><h3 id="I-O-连接器"><a href="#I-O-连接器" class="headerlink" title="I&#x2F;O 连接器"></a>I&#x2F;O 连接器</h3><p>参考文件：<span class="exturl" data-url="aHR0cHM6Ly90b21jYXQuYXBhY2hlLm9yZy90b21jYXQtNy4wLWRvYy9jb25maWcvaHR0cC5odG1s">https://tomcat.apache.org/tomcat-7.0-doc/config/http.html<i class="fa fa-external-link-alt"></i></span></p><p>实现类：<code>org.apache.catalina.connector.Connector</code></p><p>注意实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProtocol</span><span class="params">(String protocol)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;HTTP/1.1&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">            setProtocolHandlerClassName</span><br><span class="line">                (<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AJP/1.3&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">            setProtocolHandlerClassName</span><br><span class="line">                (<span class="string">&quot;org.apache.coyote.ajp.AjpAprProtocol&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol != <span class="literal">null</span>) &#123;</span><br><span class="line">            setProtocolHandlerClassName(protocol);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setProtocolHandlerClassName</span><br><span class="line">                (<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;HTTP/1.1&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">            setProtocolHandlerClassName</span><br><span class="line">                (<span class="string">&quot;org.apache.coyote.http11.Http11Protocol&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AJP/1.3&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">            setProtocolHandlerClassName</span><br><span class="line">                (<span class="string">&quot;org.apache.coyote.ajp.AjpProtocol&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol != <span class="literal">null</span>) &#123;</span><br><span class="line">            setProtocolHandlerClassName(protocol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问答互动"><a href="#问答互动" class="headerlink" title="问答互动"></a>问答互动</h2><h3 id="问题一：如果配置path的话-是以文件名为主-还是-以配置的为主"><a href="#问题一：如果配置path的话-是以文件名为主-还是-以配置的为主" class="headerlink" title="问题一：如果配置path的话 是以文件名为主 还是 以配置的为主"></a>问题一：如果配置path的话 是以文件名为主 还是 以配置的为主</h3><p>独立 context XML 配置文件时，设置 <code>path</code> 属性是无效的。</p><h3 id="问题二：根独立-context-XML-配置文件路径"><a href="#问题二：根独立-context-XML-配置文件路径" class="headerlink" title="问题二：根独立 context XML 配置文件路径"></a>问题二：根独立 context XML 配置文件路径</h3><p><code>$&#123;TOMCAT_HOME&#125;/conf/$&#123;Engine.name&#125;/$&#123;HOST.name&#125;/ROOT.xml</code></p><h3 id="问题三：如果实现热部署"><a href="#问题三：如果实现热部署" class="headerlink" title="问题三：如果实现热部署"></a>问题三：如果实现热部署</h3><p>调整 <code>&lt;context&gt;</code> 元素中的属性<code>reloadable=&quot;true&quot; </code></p><h3 id="问题四：连接器里面的线程池-是用的哪个线程池"><a href="#问题四：连接器里面的线程池-是用的哪个线程池" class="headerlink" title="问题四：连接器里面的线程池 是用的哪个线程池"></a>问题四：连接器里面的线程池 是用的哪个线程池</h3><p>注意<code>conf/server.xml</code> 文件中的一段注释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">&quot;tomcatThreadPool&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>org.apache.catalina.Executor</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Executor, Lifecycle &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &lt;tt&gt;Executor&lt;/tt&gt; implementation.</span></span><br><span class="line"><span class="comment">     * If no threads are available, it will be added to the work queue.</span></span><br><span class="line"><span class="comment">     * If the work queue is full, the system will wait for the specified</span></span><br><span class="line"><span class="comment">     * time until it throws a RejectedExecutionException</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.util.concurrent.RejectedExecutionException if this task</span></span><br><span class="line"><span class="comment">     * cannot be accepted for execution - the queue is full</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command or unit is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command, <span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准实现：<code>org.apache.catalina.core.StandardThreadExecutor</code> 将连接处理交付给 Java 标准线程池：</p><p><code>org.apache.tomcat.util.threads.ThreadPoolExecutor</code>。</p><h3 id="问题五：JNDI-能不能稍微说下-之前只是在数据源的时候用过，但是不是太理解"><a href="#问题五：JNDI-能不能稍微说下-之前只是在数据源的时候用过，但是不是太理解" class="headerlink" title="问题五：JNDI 能不能稍微说下 之前只是在数据源的时候用过，但是不是太理解"></a>问题五：JNDI 能不能稍微说下 之前只是在数据源的时候用过，但是不是太理解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;mail/Session&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;javax.mail.Session&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">mail.smtp.host</span>=<span class="string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">initCtx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">Context</span> <span class="variable">envCtx</span> <span class="operator">=</span> (Context) initCtx.lookup(<span class="string">&quot;java:comp/env&quot;</span>);</span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> (Session) envCtx.lookup(<span class="string">&quot;mail/Session&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessage</span>(session);</span><br><span class="line">message.setFrom(<span class="keyword">new</span> <span class="title class_">InternetAddress</span>(request.getParameter(<span class="string">&quot;from&quot;</span>)));</span><br><span class="line">InternetAddress to[] = <span class="keyword">new</span> <span class="title class_">InternetAddress</span>[<span class="number">1</span>];</span><br><span class="line">to[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(request.getParameter(<span class="string">&quot;to&quot;</span>));</span><br><span class="line">message.setRecipients(Message.RecipientType.TO, to);</span><br><span class="line">message.setSubject(request.getParameter(<span class="string">&quot;subject&quot;</span>));</span><br><span class="line">message.setContent(request.getParameter(<span class="string">&quot;content&quot;</span>), <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">Transport.send(message);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tomcat-架构&quot;&gt;&lt;a href=&quot;#Tomcat-架构&quot; class=&quot;headerlink&quot; title=&quot;Tomcat 架构&quot;&gt;&lt;/a&gt;Tomcat 架构&lt;/h1&gt;&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>序列化</title>
    <link href="http://yoursite.com/2018/01/13/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/13/%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2018-01-13T13:05:41.000Z</published>
    <updated>2024-07-31T03:16:37.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="评价序列化算法优劣的指标"><a href="#评价序列化算法优劣的指标" class="headerlink" title="评价序列化算法优劣的指标"></a>评价序列化算法优劣的指标</h3><ul><li>序列化后的数据的大小</li><li>序列化操作本身的速度及系统资源开销（CPU&#x2F;内存）</li></ul><h3 id="Java序列化机制存在问题"><a href="#Java序列化机制存在问题" class="headerlink" title="Java序列化机制存在问题"></a>Java序列化机制存在问题</h3><ul><li>序列化的数据比较大，传输效率低</li><li>其他语言无法识别和对接</li></ul><h3 id="常见序列化技术"><a href="#常见序列化技术" class="headerlink" title="常见序列化技术"></a>常见序列化技术</h3><ul><li>json、jackson、fastjson、gson</li><li>xml</li><li>webservice</li><li>hessian2</li><li>protobuf</li><li>thrift</li><li>avro</li><li>messagepack</li><li>fst</li></ul><p>序列化性能比较：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Vpc2hheS9qdm0tc2VyaWFsaXplcnMvd2lraQ==">https://github.com/eishay/jvm-serializers/wiki<i class="fa fa-external-link-alt"></i></span></p><h3 id="序列化技术的选型"><a href="#序列化技术的选型" class="headerlink" title="序列化技术的选型"></a>序列化技术的选型</h3><h4 id="技术层面"><a href="#技术层面" class="headerlink" title="技术层面"></a>技术层面</h4><ol><li>序列化空间开销，也就是序列化产生的结果大小，这个影响到传输的<br> 性能 </li><li>序列化过程中消耗的时长，序列化消耗时间过长影响到业务的响应<br> 时间 </li><li>序列化协议是否支持跨平台，跨语言。因为现在的架构更加灵活，如<br> 果存在异构系统通信需求，那么这个是必须要考虑的 </li><li>可扩展性&#x2F;兼容性，在实际业务开发中，系统往往需要随着需求的快<br> 速迭代来实现快速更新，这就要求我们采用的序列化协议基于良好<br> 做技术人的之路明灯，做职场生涯的精神导师<br> 的可扩展性&#x2F;兼容性，比如在现有的序列化数据结构中新增一个业务<br> 字段，不会影响到现有的服务 </li><li>技术的流行程度，越流行的技术意味着使用的公司多，那么很多坑都<br> 已经淌过并且得到了解决，技术解决方案也相对成熟 </li><li>学习难度和易用性</li></ol><h4 id="选型建议"><a href="#选型建议" class="headerlink" title="选型建议"></a>选型建议</h4><ol><li>对性能要求不高的场景，可以采用基于XML的SOAP协议 </li><li>对性能和间接性有比较高要求的场景，那么Hessian、Protobuf、Thrift、</li></ol><p>Avro都可以。 </p><ol start="3"><li>基于前后端分离，或者独立的对外的api服务，选用JSON是比较好</li></ol><p>的，对于调试、可读性都很不错 </p><ol start="4"><li>Avro 设计理念偏于动态类型语言，那么这类的场景使用 Avro 是可</li></ol><p>以的 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;评价序列化算法优劣的指标&quot;&gt;&lt;a href=&quot;#评价序列化算法优劣的指标&quot; class=&quot;headerlink&quot; title=&quot;评价序列化算法优劣的指标&quot;&gt;&lt;/a&gt;评价序列化算法优劣的指标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;序列化后的数据的大小&lt;/li&gt;
&lt;li&gt;序列化操</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="序列化" scheme="http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
